{"file_contents":{"client/components/ThemedView.tsx":{"content":"import { View, type ViewProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type ThemedViewProps = ViewProps & {\n  lightColor?: string;\n  darkColor?: string;\n};\n\nexport function ThemedView({\n  style,\n  lightColor,\n  darkColor,\n  ...otherProps\n}: ThemedViewProps) {\n  const { theme, isDark } = useTheme();\n\n  const backgroundColor =\n    isDark && darkColor\n      ? darkColor\n      : !isDark && lightColor\n        ? lightColor\n        : theme.backgroundRoot;\n\n  return <View style={[{ backgroundColor }, style]} {...otherProps} />;\n}\n","path":null,"size_bytes":563,"size_tokens":null},"client/screens/ScannerScreen.tsx":{"content":"import React, { useState, useCallback } from \"react\";\nimport { View, TextInput, StyleSheet, Pressable, Platform, Alert } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Colors, Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Feather } from \"@expo/vector-icons\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { emitContactRequest } from \"@/lib/socket\";\nimport { apiRequest } from \"@/lib/query-client\";\nimport * as Haptics from \"expo-haptics\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nexport default function ScannerScreen() {\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation<NavigationProp>();\n  const { user } = useAuth();\n  const [code, setCode] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleSubmit = useCallback(async () => {\n    if (!code.trim() || !user) return;\n\n    setError(null);\n    setIsLoading(true);\n\n    try {\n      const response = await apiRequest(\"GET\", `/api/users/code/${code.trim().toUpperCase()}`);\n      \n      if (!response.ok) {\n        setError(\"User not found with this code\");\n        setIsLoading(false);\n        return;\n      }\n\n      const foundUser = await response.json();\n\n      if (foundUser.id === user.id) {\n        setError(\"You cannot add yourself as a contact\");\n        setIsLoading(false);\n        return;\n      }\n\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      \n      emitContactRequest({\n        fromUserId: user.id,\n        toUserId: foundUser.id,\n      });\n\n      Alert.alert(\n        \"Request Sent\",\n        `Connection request sent to ${foundUser.username}. They will need to accept your request.`,\n        [{ text: \"OK\", onPress: () => navigation.goBack() }]\n      );\n    } catch (err: any) {\n      setError(err.message || \"Failed to find user\");\n    } finally {\n      setIsLoading(false);\n    }\n  }, [code, user, navigation]);\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.content, { paddingTop: Spacing[\"2xl\"], paddingBottom: insets.bottom + Spacing.xl }]}>\n        <View style={styles.cameraPlaceholder}>\n          <Feather name=\"camera-off\" size={48} color={Colors.dark.textTertiary} />\n          <ThemedText style={styles.placeholderText}>\n            Camera scanning available in Expo Go\n          </ThemedText>\n        </View>\n\n        <View style={styles.divider}>\n          <View style={styles.dividerLine} />\n          <ThemedText style={styles.dividerText}>OR ENTER CODE</ThemedText>\n          <View style={styles.dividerLine} />\n        </View>\n\n        <View style={styles.inputSection}>\n          <ThemedText style={styles.label}>&gt; ENTER PAIRING CODE</ThemedText>\n          <View style={styles.inputContainer}>\n            <ThemedText style={styles.prompt}>$</ThemedText>\n            <TextInput\n              style={styles.input}\n              value={code}\n              onChangeText={(text) => setCode(text.toUpperCase())}\n              placeholder=\"XXXXXXXX\"\n              placeholderTextColor={Colors.dark.textTertiary}\n              autoCapitalize=\"characters\"\n              autoCorrect={false}\n              maxLength={8}\n            />\n          </View>\n\n          {error ? (\n            <ThemedText style={styles.error}>[ERROR] {error}</ThemedText>\n          ) : null}\n\n          <Pressable\n            style={({ pressed }) => [\n              styles.button,\n              pressed && styles.buttonPressed,\n              (!code.trim() || isLoading) && styles.buttonDisabled,\n            ]}\n            onPress={handleSubmit}\n            disabled={!code.trim() || isLoading}\n          >\n            <Feather name=\"user-plus\" size={18} color={Colors.dark.buttonText} />\n            <ThemedText style={styles.buttonText}>\n              {isLoading ? \"SEARCHING...\" : \"SEND REQUEST\"}\n            </ThemedText>\n          </Pressable>\n        </View>\n\n        <View style={styles.infoBox}>\n          <Feather name=\"info\" size={14} color={Colors.dark.primary} />\n          <ThemedText style={styles.infoText}>\n            Ask your contact to share their pairing code from their Profile screen. \n            Once you send a request, they will need to accept it before you can start messaging.\n          </ThemedText>\n        </View>\n      </View>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, backgroundColor: Colors.dark.backgroundRoot },\n  content: { flex: 1, paddingHorizontal: Spacing.lg },\n  cameraPlaceholder: { height: 200, backgroundColor: Colors.dark.backgroundDefault, borderRadius: BorderRadius.md, borderWidth: 1, borderColor: Colors.dark.border, justifyContent: \"center\", alignItems: \"center\", marginBottom: Spacing.xl },\n  placeholderText: { fontSize: 12, color: Colors.dark.textTertiary, fontFamily: Fonts?.mono, marginTop: Spacing.md, textAlign: \"center\" },\n  divider: { flexDirection: \"row\", alignItems: \"center\", marginBottom: Spacing.xl },\n  dividerLine: { flex: 1, height: 1, backgroundColor: Colors.dark.border },\n  dividerText: { fontSize: 12, color: Colors.dark.textSecondary, fontFamily: Fonts?.mono, paddingHorizontal: Spacing.md, letterSpacing: 0.5 },\n  inputSection: { marginBottom: Spacing.xl },\n  label: { fontSize: 14, color: Colors.dark.secondary, fontFamily: Fonts?.mono, marginBottom: Spacing.md, letterSpacing: 0.5 },\n  inputContainer: { flexDirection: \"row\", alignItems: \"center\", backgroundColor: Colors.dark.backgroundDefault, borderWidth: 1, borderColor: Colors.dark.border, borderRadius: BorderRadius.sm, paddingHorizontal: Spacing.md, height: Spacing.inputHeight, marginBottom: Spacing.lg },\n  prompt: { fontSize: 16, color: Colors.dark.secondary, fontFamily: Fonts?.mono, marginRight: Spacing.sm },\n  input: { flex: 1, fontSize: 18, color: Colors.dark.text, fontFamily: Fonts?.mono, letterSpacing: 4 },\n  error: { fontSize: 12, color: Colors.dark.danger, fontFamily: Fonts?.mono, marginBottom: Spacing.lg },\n  button: { flexDirection: \"row\", alignItems: \"center\", justifyContent: \"center\", backgroundColor: Colors.dark.primary, height: Spacing.buttonHeight, borderRadius: BorderRadius.sm, gap: Spacing.sm },\n  buttonPressed: { opacity: 0.8 },\n  buttonDisabled: { opacity: 0.5 },\n  buttonText: { fontSize: 14, fontWeight: \"600\", color: Colors.dark.buttonText, fontFamily: Fonts?.mono, letterSpacing: 1 },\n  infoBox: { flexDirection: \"row\", alignItems: \"flex-start\", backgroundColor: Colors.dark.backgroundDefault, borderWidth: 1, borderColor: Colors.dark.border, borderRadius: BorderRadius.sm, padding: Spacing.md, gap: Spacing.sm },\n  infoText: { flex: 1, fontSize: 12, color: Colors.dark.textSecondary, fontFamily: Fonts?.mono, lineHeight: 18 },\n});\n","path":null,"size_bytes":7117,"size_tokens":null},"client/components/HeaderTitle.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image } from \"react-native\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface HeaderTitleProps {\n  title: string;\n}\n\nexport function HeaderTitle({ title }: HeaderTitleProps) {\n  return (\n    <View style={styles.container}>\n      <Image\n        source={require(\"../../assets/images/icon.png\")}\n        style={styles.icon}\n        resizeMode=\"contain\"\n      />\n      <ThemedText style={styles.title}>{title}</ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"flex-start\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":832,"size_tokens":null},"babel.config.js":{"content":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./\"],\n          alias: {\n            \"@\": \"./client\",\n            \"@shared\": \"./shared\",\n          },\n          extensions: [\".ios.js\", \".android.js\", \".js\", \".ts\", \".tsx\", \".json\"],\n        },\n      ],\n      \"react-native-reanimated/plugin\",\n    ],\n  };\n};\n","path":null,"size_bytes":436,"size_tokens":null},"client/lib/socket.ts":{"content":"import { io, Socket } from \"socket.io-client\";\nimport { getApiUrl } from \"@/lib/query-client\";\n\nlet socket: Socket | null = null;\nlet currentUserId: string | null = null;\n\nexport function getSocket(): Socket {\n  if (!socket) {\n    const url = getApiUrl();\n    socket = io(url, {\n      transports: [\"websocket\", \"polling\"],\n      autoConnect: true,\n    });\n    \n    socket.on(\"connect\", () => {\n      if (currentUserId) {\n        socket?.emit(\"user:online\", currentUserId);\n      }\n    });\n  }\n  return socket;\n}\n\nexport function disconnectSocket(): void {\n  if (socket) {\n    socket.disconnect();\n    socket = null;\n  }\n  currentUserId = null;\n}\n\nexport interface MessagePayload {\n  senderId: string;\n  recipientId: string;\n  encryptedContent: string;\n  nonce: string;\n  isEncrypted: boolean;\n  selfDestructSeconds?: number;\n}\n\nexport interface ContactRequestPayload {\n  fromUserId: string;\n  toUserId: string;\n}\n\nexport interface ContactAcceptPayload {\n  requestId: string;\n  userId: string;\n  contactId: string;\n}\n\nexport function emitUserOnline(userId: string): void {\n  currentUserId = userId;\n  const s = getSocket();\n  if (s.connected) {\n    s.emit(\"user:online\", userId);\n  }\n}\n\nexport function emitSendMessage(payload: MessagePayload): void {\n  getSocket().emit(\"message:send\", payload);\n}\n\nexport function emitMessageRead(messageId: string): void {\n  getSocket().emit(\"message:read\", messageId);\n}\n\nexport function emitTyping(senderId: string, recipientId: string): void {\n  getSocket().emit(\"message:typing\", { senderId, recipientId });\n}\n\nexport function emitContactRequest(payload: ContactRequestPayload): void {\n  getSocket().emit(\"contact:request\", payload);\n}\n\nexport function emitContactAccept(payload: ContactAcceptPayload): void {\n  getSocket().emit(\"contact:accept\", payload);\n}\n\nexport function emitContactReject(requestId: string): void {\n  getSocket().emit(\"contact:reject\", { requestId });\n}\n\nexport function emitContactDelete(userId: string, contactId: string): void {\n  getSocket().emit(\"contact:delete\", { userId, contactId });\n}\n","path":null,"size_bytes":2056,"size_tokens":null},"client/navigation/RootStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport MainTabNavigator from \"@/navigation/MainTabNavigator\";\nimport RegisterScreen from \"@/screens/RegisterScreen\";\nimport ChatScreen from \"@/screens/ChatScreen\";\nimport ScannerScreen from \"@/screens/ScannerScreen\";\nimport VerifyContactScreen from \"@/screens/VerifyContactScreen\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Colors } from \"@/constants/theme\";\nimport { ActivityIndicator, View } from \"react-native\";\n\nexport type RootStackParamList = {\n  Register: undefined;\n  Main: undefined;\n  Chat: { contactId: string; contactName: string; contactPublicKey: string };\n  Scanner: undefined;\n  VerifyContact: { contactId: string; contactName: string; contactPublicKey: string };\n};\n\nconst Stack = createNativeStackNavigator<RootStackParamList>();\n\nexport default function RootStackNavigator() {\n  const screenOptions = useScreenOptions();\n  const { isAuthenticated, isLoading } = useAuth();\n\n  if (isLoading) {\n    return (\n      <View style={{ flex: 1, justifyContent: \"center\", alignItems: \"center\", backgroundColor: Colors.dark.backgroundRoot }}>\n        <ActivityIndicator size=\"large\" color={Colors.dark.primary} />\n      </View>\n    );\n  }\n\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        ...screenOptions,\n        headerStyle: {\n          backgroundColor: Colors.dark.backgroundRoot,\n        },\n        headerTintColor: Colors.dark.primary,\n        contentStyle: {\n          backgroundColor: Colors.dark.backgroundRoot,\n        },\n      }}\n    >\n      {!isAuthenticated ? (\n        <Stack.Screen\n          name=\"Register\"\n          component={RegisterScreen}\n          options={{ headerShown: false }}\n        />\n      ) : (\n        <>\n          <Stack.Screen\n            name=\"Main\"\n            component={MainTabNavigator}\n            options={{ headerShown: false }}\n          />\n          <Stack.Screen\n            name=\"Chat\"\n            component={ChatScreen}\n            options={{\n              headerTitle: \"\",\n              headerBackTitle: \"Back\",\n            }}\n          />\n          <Stack.Screen\n            name=\"Scanner\"\n            component={ScannerScreen}\n            options={{\n              presentation: \"modal\",\n              headerTitle: \"SCAN QR CODE\",\n            }}\n          />\n          <Stack.Screen\n            name=\"VerifyContact\"\n            component={VerifyContactScreen}\n            options={{\n              headerTitle: \"VERIFY CONTACT\",\n            }}\n          />\n        </>\n      )}\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":2659,"size_tokens":null},"server/index.ts":{"content":"import express from \"express\";\nimport type { Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst app = express();\nconst log = console.log;\n\ndeclare module \"http\" {\n  interface IncomingMessage {\n    rawBody: unknown;\n  }\n}\n\nfunction setupCors(app: express.Application) {\n  app.use((req, res, next) => {\n    const origins = new Set<string>();\n\n    if (process.env.REPLIT_DEV_DOMAIN) {\n      origins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);\n    }\n\n    if (process.env.REPLIT_DOMAINS) {\n      process.env.REPLIT_DOMAINS.split(\",\").forEach((d) => {\n        origins.add(`https://${d.trim()}`);\n      });\n    }\n\n    const origin = req.header(\"origin\");\n\n    if (origin && origins.has(origin)) {\n      res.header(\"Access-Control-Allow-Origin\", origin);\n      res.header(\n        \"Access-Control-Allow-Methods\",\n        \"GET, POST, PUT, DELETE, OPTIONS\",\n      );\n      res.header(\"Access-Control-Allow-Headers\", \"Content-Type\");\n      res.header(\"Access-Control-Allow-Credentials\", \"true\");\n    }\n\n    if (req.method === \"OPTIONS\") {\n      return res.sendStatus(200);\n    }\n\n    next();\n  });\n}\n\nfunction setupBodyParsing(app: express.Application) {\n  app.use(\n    express.json({\n      verify: (req, _res, buf) => {\n        req.rawBody = buf;\n      },\n    }),\n  );\n\n  app.use(express.urlencoded({ extended: false }));\n}\n\nfunction setupRequestLogging(app: express.Application) {\n  app.use((req, res, next) => {\n    const start = Date.now();\n    const path = req.path;\n    let capturedJsonResponse: Record<string, unknown> | undefined = undefined;\n\n    const originalResJson = res.json;\n    res.json = function (bodyJson, ...args) {\n      capturedJsonResponse = bodyJson;\n      return originalResJson.apply(res, [bodyJson, ...args]);\n    };\n\n    res.on(\"finish\", () => {\n      if (!path.startsWith(\"/api\")) return;\n\n      const duration = Date.now() - start;\n\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"â€¦\";\n      }\n\n      log(logLine);\n    });\n\n    next();\n  });\n}\n\nfunction getAppName(): string {\n  try {\n    const appJsonPath = path.resolve(process.cwd(), \"app.json\");\n    const appJsonContent = fs.readFileSync(appJsonPath, \"utf-8\");\n    const appJson = JSON.parse(appJsonContent);\n    return appJson.expo?.name || \"App Landing Page\";\n  } catch {\n    return \"App Landing Page\";\n  }\n}\n\nfunction serveExpoManifest(platform: string, res: Response) {\n  const manifestPath = path.resolve(\n    process.cwd(),\n    \"static-build\",\n    platform,\n    \"manifest.json\",\n  );\n\n  if (!fs.existsSync(manifestPath)) {\n    return res\n      .status(404)\n      .json({ error: `Manifest not found for platform: ${platform}` });\n  }\n\n  res.setHeader(\"expo-protocol-version\", \"1\");\n  res.setHeader(\"expo-sfv-version\", \"0\");\n  res.setHeader(\"content-type\", \"application/json\");\n\n  const manifest = fs.readFileSync(manifestPath, \"utf-8\");\n  res.send(manifest);\n}\n\nfunction serveLandingPage({\n  req,\n  res,\n  landingPageTemplate,\n  appName,\n}: {\n  req: Request;\n  res: Response;\n  landingPageTemplate: string;\n  appName: string;\n}) {\n  const forwardedProto = req.header(\"x-forwarded-proto\");\n  const protocol = forwardedProto || req.protocol || \"https\";\n  const forwardedHost = req.header(\"x-forwarded-host\");\n  const host = forwardedHost || req.get(\"host\");\n  const baseUrl = `${protocol}://${host}`;\n  const expsUrl = `${host}`;\n\n  log(`baseUrl`, baseUrl);\n  log(`expsUrl`, expsUrl);\n\n  const html = landingPageTemplate\n    .replace(/BASE_URL_PLACEHOLDER/g, baseUrl)\n    .replace(/EXPS_URL_PLACEHOLDER/g, expsUrl)\n    .replace(/APP_NAME_PLACEHOLDER/g, appName);\n\n  res.setHeader(\"Content-Type\", \"text/html; charset=utf-8\");\n  res.status(200).send(html);\n}\n\nfunction configureExpoAndLanding(app: express.Application) {\n  const templatePath = path.resolve(\n    process.cwd(),\n    \"server\",\n    \"templates\",\n    \"landing-page.html\",\n  );\n  const landingPageTemplate = fs.readFileSync(templatePath, \"utf-8\");\n  const appName = getAppName();\n\n  log(\"Serving static Expo files with dynamic manifest routing\");\n\n  app.use((req: Request, res: Response, next: NextFunction) => {\n    if (req.path.startsWith(\"/api\")) {\n      return next();\n    }\n\n    if (req.path !== \"/\" && req.path !== \"/manifest\") {\n      return next();\n    }\n\n    const platform = req.header(\"expo-platform\");\n    if (platform && (platform === \"ios\" || platform === \"android\")) {\n      return serveExpoManifest(platform, res);\n    }\n\n    if (req.path === \"/\") {\n      return serveLandingPage({\n        req,\n        res,\n        landingPageTemplate,\n        appName,\n      });\n    }\n\n    next();\n  });\n\n  app.use(\"/assets\", express.static(path.resolve(process.cwd(), \"assets\")));\n  app.use(express.static(path.resolve(process.cwd(), \"static-build\")));\n\n  log(\"Expo routing: Checking expo-platform header on / and /manifest\");\n}\n\nfunction setupErrorHandler(app: express.Application) {\n  app.use((err: unknown, _req: Request, res: Response, _next: NextFunction) => {\n    const error = err as {\n      status?: number;\n      statusCode?: number;\n      message?: string;\n    };\n\n    const status = error.status || error.statusCode || 500;\n    const message = error.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n\n    throw err;\n  });\n}\n\n(async () => {\n  setupCors(app);\n  setupBodyParsing(app);\n  setupRequestLogging(app);\n\n  configureExpoAndLanding(app);\n\n  const server = await registerRoutes(app);\n\n  setupErrorHandler(app);\n\n  const port = parseInt(process.env.PORT || \"5000\", 10);\n  server.listen(\n    {\n      port,\n      host: \"0.0.0.0\",\n      reusePort: true,\n    },\n    () => {\n      log(`express server serving on port ${port}`);\n    },\n  );\n})();\n","path":null,"size_bytes":5949,"size_tokens":null},"server/storage.ts":{"content":"import {\n  users,\n  contacts,\n  messages,\n  contactRequests,\n  type User,\n  type Contact,\n  type Message,\n  type ContactRequest,\n  type InsertUser,\n  type InsertContact,\n  type InsertMessage,\n  type InsertContactRequest,\n} from \"@shared/schema\";\nimport { db } from \"./db\";\nimport { eq, and, or, desc, isNull } from \"drizzle-orm\";\n\nexport interface IStorage {\n  getUser(id: string): Promise<User | undefined>;\n  getUserByUsername(username: string): Promise<User | undefined>;\n  getUserByPairingCode(code: string): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n  updateUserOnlineStatus(userId: string, isOnline: boolean): Promise<void>;\n  \n  getContacts(userId: string): Promise<(Contact & { contact: User })[]>;\n  getContact(userId: string, contactId: string): Promise<Contact | undefined>;\n  createContact(contact: InsertContact): Promise<Contact>;\n  updateContactVerification(id: string, isVerified: boolean, safetyNumber: string): Promise<void>;\n  deleteContact(userId: string, contactId: string): Promise<void>;\n  \n  getMessages(userId: string, contactId: string): Promise<Message[]>;\n  createMessage(message: InsertMessage): Promise<Message>;\n  markMessageAsRead(messageId: string): Promise<void>;\n  markMessageAsDelivered(messageId: string): Promise<void>;\n  deleteMessage(messageId: string): Promise<void>;\n  getExpiredMessages(): Promise<Message[]>;\n  \n  getContactRequests(userId: string): Promise<(ContactRequest & { fromUser: User })[]>;\n  getSentContactRequests(userId: string): Promise<(ContactRequest & { toUser: User })[]>;\n  createContactRequest(request: InsertContactRequest): Promise<ContactRequest>;\n  updateContactRequestStatus(id: string, status: string): Promise<void>;\n  getContactRequest(fromUserId: string, toUserId: string): Promise<ContactRequest | undefined>;\n}\n\nexport class DatabaseStorage implements IStorage {\n  async getUser(id: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.id, id));\n    return user || undefined;\n  }\n\n  async getUserByUsername(username: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.username, username));\n    return user || undefined;\n  }\n\n  async getUserByPairingCode(code: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.pairingCode, code));\n    return user || undefined;\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const [user] = await db.insert(users).values(insertUser).returning();\n    return user;\n  }\n\n  async updateUserOnlineStatus(userId: string, isOnline: boolean): Promise<void> {\n    await db.update(users)\n      .set({ isOnline, lastSeen: new Date() })\n      .where(eq(users.id, userId));\n  }\n\n  async getContacts(userId: string): Promise<(Contact & { contact: User })[]> {\n    const result = await db\n      .select()\n      .from(contacts)\n      .innerJoin(users, eq(contacts.contactId, users.id))\n      .where(eq(contacts.userId, userId));\n    \n    return result.map(r => ({\n      ...r.contacts,\n      contact: r.users,\n    }));\n  }\n\n  async getContact(userId: string, contactId: string): Promise<Contact | undefined> {\n    const [contact] = await db\n      .select()\n      .from(contacts)\n      .where(and(eq(contacts.userId, userId), eq(contacts.contactId, contactId)));\n    return contact || undefined;\n  }\n\n  async createContact(insertContact: InsertContact): Promise<Contact> {\n    const [contact] = await db.insert(contacts).values(insertContact).returning();\n    return contact;\n  }\n\n  async updateContactVerification(id: string, isVerified: boolean, safetyNumber: string): Promise<void> {\n    await db.update(contacts)\n      .set({ isVerified, safetyNumber, updatedAt: new Date() })\n      .where(eq(contacts.id, id));\n  }\n\n  async deleteContact(userId: string, contactId: string): Promise<void> {\n    await db.delete(contacts).where(\n      and(eq(contacts.userId, userId), eq(contacts.contactId, contactId))\n    );\n    await db.delete(contacts).where(\n      and(eq(contacts.userId, contactId), eq(contacts.contactId, userId))\n    );\n  }\n\n  async getMessages(userId: string, contactId: string): Promise<Message[]> {\n    return db\n      .select()\n      .from(messages)\n      .where(\n        and(\n          isNull(messages.deletedAt),\n          or(\n            and(eq(messages.senderId, userId), eq(messages.recipientId, contactId)),\n            and(eq(messages.senderId, contactId), eq(messages.recipientId, userId))\n          )\n        )\n      )\n      .orderBy(desc(messages.createdAt));\n  }\n\n  async createMessage(insertMessage: InsertMessage): Promise<Message> {\n    const selfDestructAt = insertMessage.selfDestructSeconds\n      ? new Date(Date.now() + insertMessage.selfDestructSeconds * 1000)\n      : null;\n    \n    const [message] = await db\n      .insert(messages)\n      .values({\n        ...insertMessage,\n        selfDestructAt,\n      })\n      .returning();\n    return message;\n  }\n\n  async markMessageAsRead(messageId: string): Promise<void> {\n    await db.update(messages)\n      .set({ isRead: true })\n      .where(eq(messages.id, messageId));\n  }\n\n  async markMessageAsDelivered(messageId: string): Promise<void> {\n    await db.update(messages)\n      .set({ isDelivered: true })\n      .where(eq(messages.id, messageId));\n  }\n\n  async deleteMessage(messageId: string): Promise<void> {\n    await db.update(messages)\n      .set({ deletedAt: new Date() })\n      .where(eq(messages.id, messageId));\n  }\n\n  async getExpiredMessages(): Promise<Message[]> {\n    const now = new Date();\n    return db\n      .select()\n      .from(messages)\n      .where(\n        and(\n          isNull(messages.deletedAt),\n          eq(messages.isRead, true)\n        )\n      );\n  }\n\n  async getContactRequests(userId: string): Promise<(ContactRequest & { fromUser: User })[]> {\n    const result = await db\n      .select()\n      .from(contactRequests)\n      .innerJoin(users, eq(contactRequests.fromUserId, users.id))\n      .where(and(eq(contactRequests.toUserId, userId), eq(contactRequests.status, \"pending\")));\n    \n    return result.map(r => ({\n      ...r.contact_requests,\n      fromUser: r.users,\n    }));\n  }\n\n  async getSentContactRequests(userId: string): Promise<(ContactRequest & { toUser: User })[]> {\n    const result = await db\n      .select()\n      .from(contactRequests)\n      .innerJoin(users, eq(contactRequests.toUserId, users.id))\n      .where(eq(contactRequests.fromUserId, userId));\n    \n    return result.map(r => ({\n      ...r.contact_requests,\n      toUser: r.users,\n    }));\n  }\n\n  async createContactRequest(insertRequest: InsertContactRequest): Promise<ContactRequest> {\n    const [request] = await db.insert(contactRequests).values(insertRequest).returning();\n    return request;\n  }\n\n  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n    await db.update(contactRequests)\n      .set({ status, respondedAt: new Date() })\n      .where(eq(contactRequests.id, id));\n  }\n\n  async getContactRequest(fromUserId: string, toUserId: string): Promise<ContactRequest | undefined> {\n    const [request] = await db\n      .select()\n      .from(contactRequests)\n      .where(\n        and(\n          eq(contactRequests.fromUserId, fromUserId),\n          eq(contactRequests.toUserId, toUserId)\n        )\n      );\n    return request || undefined;\n  }\n}\n\nexport const storage = new DatabaseStorage();\n","path":null,"size_bytes":7411,"size_tokens":null},"client/hooks/useColorScheme.web.ts":{"content":"import { useEffect, useState } from \"react\";\nimport { useColorScheme as useRNColorScheme } from \"react-native\";\n\n/**\n * To support static rendering, this value needs to be re-calculated on the client side for web\n */\nexport function useColorScheme() {\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const colorScheme = useRNColorScheme();\n\n  if (hasHydrated) {\n    return colorScheme;\n  }\n\n  return \"light\";\n}\n","path":null,"size_bytes":480,"size_tokens":null},"client/lib/query-client.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\n/**\n * Gets the base URL for the Express API server (e.g., \"http://localhost:3000\")\n * @returns {string} The API base URL\n */\nexport function getApiUrl(): string {\n  let host = process.env.EXPO_PUBLIC_DOMAIN;\n\n  if (!host) {\n    throw new Error(\"EXPO_PUBLIC_DOMAIN is not set\");\n  }\n\n  let url = new URL(`https://${host}`);\n\n  return url.href;\n}\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  route: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const baseUrl = getApiUrl();\n  const url = new URL(route, baseUrl);\n\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const baseUrl = getApiUrl();\n    const url = new URL(queryKey.join(\"/\") as string, baseUrl);\n\n    const res = await fetch(url, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","path":null,"size_bytes":1876,"size_tokens":null},"client/components/ErrorBoundary.tsx":{"content":"import React, { Component, ComponentType, PropsWithChildren } from \"react\";\nimport { ErrorFallback, ErrorFallbackProps } from \"@/components/ErrorFallback\";\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  FallbackComponent?: ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, stackTrace: string) => void;\n}>;\n\ntype ErrorBoundaryState = { error: Error | null };\n\n/**\n * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.\n * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary\n */\n\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = { error: null };\n\n  static defaultProps: {\n    FallbackComponent: ComponentType<ErrorFallbackProps>;\n  } = {\n    FallbackComponent: ErrorFallback,\n  };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: { componentStack: string }): void {\n    if (typeof this.props.onError === \"function\") {\n      this.props.onError(error, info.componentStack);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({ error: null });\n  };\n\n  render() {\n    const { FallbackComponent } = this.props;\n\n    return this.state.error && FallbackComponent ? (\n      <FallbackComponent\n        error={this.state.error}\n        resetError={this.resetError}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n","path":null,"size_bytes":1674,"size_tokens":null},"client/index.js":{"content":"import \"react-native-get-random-values\";\nimport { registerRootComponent } from \"expo\";\n\nimport App from \"@/App\";\n\nregisterRootComponent(App);\n","path":null,"size_bytes":142,"size_tokens":null},"client/screens/ContactsScreen.tsx":{"content":"import React, { useEffect, useState, useCallback } from \"react\";\nimport {\n  View,\n  FlatList,\n  StyleSheet,\n  Pressable,\n  RefreshControl,\n  Alert,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Colors, Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Feather } from \"@expo/vector-icons\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { getSocket, emitContactAccept, emitContactReject, emitContactDelete } from \"@/lib/socket\";\nimport * as Haptics from \"expo-haptics\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\ninterface Contact {\n  id: string;\n  userId: string;\n  contactId: string;\n  status: string;\n  isVerified: boolean;\n  contact: {\n    id: string;\n    username: string;\n    publicKey: string;\n    isOnline: boolean;\n  };\n}\n\ninterface ContactRequest {\n  id: string;\n  fromUserId: string;\n  toUserId: string;\n  status: string;\n  fromUser: {\n    id: string;\n    username: string;\n    publicKey: string;\n  };\n}\n\nexport default function ContactsScreen() {\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useBottomTabBarHeight();\n  const navigation = useNavigation<NavigationProp>();\n  const { user } = useAuth();\n  const queryClient = useQueryClient();\n  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());\n\n  const { data: contacts, isLoading: contactsLoading, refetch: refetchContacts } = useQuery<Contact[]>({\n    queryKey: [\"/api/contacts\", user?.id],\n    enabled: !!user?.id,\n  });\n\n  const { data: requests, isLoading: requestsLoading, refetch: refetchRequests } = useQuery<ContactRequest[]>({\n    queryKey: [\"/api/contact-requests\", user?.id],\n    enabled: !!user?.id,\n  });\n\n  useEffect(() => {\n    const socket = getSocket();\n    \n    const handleUserStatus = ({ userId, isOnline }: { userId: string; isOnline: boolean }) => {\n      setOnlineUsers(prev => {\n        const next = new Set(prev);\n        if (isOnline) {\n          next.add(userId);\n        } else {\n          next.delete(userId);\n        }\n        return next;\n      });\n    };\n\n    const handleContactRequest = () => {\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      refetchRequests();\n    };\n\n    const handleContactAccepted = () => {\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      refetchContacts();\n      refetchRequests();\n    };\n\n    const handleContactDeleted = () => {\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n      refetchContacts();\n    };\n\n    socket.on(\"user:status\", handleUserStatus);\n    socket.on(\"contact:request:received\", handleContactRequest);\n    socket.on(\"contact:accepted\", handleContactAccepted);\n    socket.on(\"contact:deleted\", handleContactDeleted);\n    socket.on(\"contact:deleted:success\", handleContactDeleted);\n\n    return () => {\n      socket.off(\"user:status\", handleUserStatus);\n      socket.off(\"contact:request:received\", handleContactRequest);\n      socket.off(\"contact:accepted\", handleContactAccepted);\n      socket.off(\"contact:deleted\", handleContactDeleted);\n      socket.off(\"contact:deleted:success\", handleContactDeleted);\n    };\n  }, [refetchRequests, refetchContacts]);\n\n  const handleAccept = useCallback(async (request: ContactRequest) => {\n    if (!user) return;\n    \n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    emitContactAccept({\n      requestId: request.id,\n      userId: user.id,\n      contactId: request.fromUserId,\n    });\n    \n    queryClient.invalidateQueries({ queryKey: [\"/api/contacts\", user.id] });\n    queryClient.invalidateQueries({ queryKey: [\"/api/contact-requests\", user.id] });\n  }, [user, queryClient]);\n\n  const handleReject = useCallback(async (request: ContactRequest) => {\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    emitContactReject(request.id);\n    refetchRequests();\n  }, [refetchRequests]);\n\n  const handleDeleteContact = useCallback((contact: Contact) => {\n    if (!user) return;\n    \n    Alert.alert(\n      \"Delete Contact\",\n      `Remove ${contact.contact.username} from your contacts? This will also remove you from their contacts.`,\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        {\n          text: \"Delete\",\n          style: \"destructive\",\n          onPress: async () => {\n            await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n            emitContactDelete(user.id, contact.contactId);\n          },\n        },\n      ]\n    );\n  }, [user]);\n\n  const openScanner = useCallback(() => {\n    navigation.navigate(\"Scanner\");\n  }, [navigation]);\n\n  const openVerify = useCallback((contact: Contact) => {\n    navigation.navigate(\"VerifyContact\", {\n      contactId: contact.contactId,\n      contactName: contact.contact.username,\n      contactPublicKey: contact.contact.publicKey,\n    });\n  }, [navigation]);\n\n  const renderRequest = useCallback(({ item }: { item: ContactRequest }) => (\n    <View style={styles.requestItem}>\n      <View style={styles.requestInfo}>\n        <View style={styles.avatar}>\n          <ThemedText style={styles.avatarText}>\n            [{item.fromUser.username.substring(0, 2).toUpperCase()}]\n          </ThemedText>\n        </View>\n        <View style={styles.requestText}>\n          <ThemedText style={styles.requestName}>{item.fromUser.username}</ThemedText>\n          <ThemedText style={styles.requestLabel}>wants to connect</ThemedText>\n        </View>\n      </View>\n      <View style={styles.requestActions}>\n        <Pressable\n          style={({ pressed }) => [styles.acceptButton, pressed && styles.buttonPressed]}\n          onPress={() => handleAccept(item)}\n        >\n          <Feather name=\"check\" size={18} color={Colors.dark.buttonText} />\n        </Pressable>\n        <Pressable\n          style={({ pressed }) => [styles.rejectButton, pressed && styles.buttonPressed]}\n          onPress={() => handleReject(item)}\n        >\n          <Feather name=\"x\" size={18} color={Colors.dark.danger} />\n        </Pressable>\n      </View>\n    </View>\n  ), [handleAccept, handleReject]);\n\n  const renderContact = useCallback(({ item }: { item: Contact }) => {\n    const isOnline = onlineUsers.has(item.contactId) || item.contact.isOnline;\n    \n    return (\n      <View style={styles.contactItem}>\n        <Pressable\n          style={({ pressed }) => [styles.contactTouchable, pressed && styles.contactItemPressed]}\n          onPress={() => openVerify(item)}\n        >\n          <View style={styles.avatarContainer}>\n            <View style={styles.avatar}>\n              <ThemedText style={styles.avatarText}>\n                [{item.contact.username.substring(0, 2).toUpperCase()}]\n              </ThemedText>\n            </View>\n            <View style={[styles.statusDot, isOnline && styles.statusOnline]} />\n          </View>\n          \n          <View style={styles.contactInfo}>\n            <ThemedText style={styles.contactName}>{item.contact.username}</ThemedText>\n            <View style={styles.verifyRow}>\n              {item.isVerified ? (\n                <>\n                  <Feather name=\"check-circle\" size={12} color={Colors.dark.secondary} />\n                  <ThemedText style={styles.verifiedText}>VERIFIED</ThemedText>\n                </>\n              ) : (\n                <>\n                  <Feather name=\"alert-triangle\" size={12} color={Colors.dark.warning} />\n                  <ThemedText style={styles.unverifiedText}>TAP TO VERIFY</ThemedText>\n                </>\n              )}\n            </View>\n          </View>\n        </Pressable>\n        \n        <Pressable\n          style={({ pressed }) => [styles.deleteButton, pressed && styles.buttonPressed]}\n          onPress={() => handleDeleteContact(item)}\n        >\n          <Feather name=\"trash-2\" size={16} color={Colors.dark.danger} />\n        </Pressable>\n      </View>\n    );\n  }, [onlineUsers, openVerify, handleDeleteContact]);\n\n  const acceptedContacts = contacts?.filter(c => c.status === \"accepted\") || [];\n  const pendingRequests = requests?.filter(r => r.status === \"pending\") || [];\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <ThemedText style={styles.title}>CONTACTS</ThemedText>\n        <Pressable\n          style={({ pressed }) => [styles.addButton, pressed && styles.addButtonPressed]}\n          onPress={openScanner}\n        >\n          <Feather name=\"user-plus\" size={18} color={Colors.dark.primary} />\n        </Pressable>\n      </View>\n\n      <FlatList\n        data={[...pendingRequests.map(r => ({ type: \"request\" as const, data: r })), ...acceptedContacts.map(c => ({ type: \"contact\" as const, data: c }))]}\n        keyExtractor={(item) => item.data.id}\n        renderItem={({ item }) => \n          item.type === \"request\" \n            ? renderRequest({ item: item.data as ContactRequest })\n            : renderContact({ item: item.data as Contact })\n        }\n        ListHeaderComponent={\n          pendingRequests.length > 0 ? (\n            <View style={styles.sectionHeader}>\n              <ThemedText style={styles.sectionTitle}>\n                $ PENDING REQUESTS ({pendingRequests.length})\n              </ThemedText>\n            </View>\n          ) : null\n        }\n        ListEmptyComponent={\n          <View style={styles.emptyContainer}>\n            <View style={styles.emptyIcon}>\n              <Feather name=\"users\" size={48} color={Colors.dark.textTertiary} />\n            </View>\n            <ThemedText style={styles.emptyTitle}>NO CONTACTS YET</ThemedText>\n            <ThemedText style={styles.emptySubtitle}>\n              $ Scan a QR code to add secure contacts\n            </ThemedText>\n          </View>\n        }\n        contentContainerStyle={[\n          styles.list,\n          { paddingBottom: tabBarHeight + Spacing.xl + 60 },\n        ]}\n        refreshControl={\n          <RefreshControl\n            refreshing={contactsLoading || requestsLoading}\n            onRefresh={() => { refetchContacts(); refetchRequests(); }}\n            tintColor={Colors.dark.primary}\n          />\n        }\n      />\n\n      <Pressable\n        style={({ pressed }) => [\n          styles.fab,\n          { bottom: tabBarHeight + Spacing.xl },\n          pressed && styles.fabPressed,\n        ]}\n        onPress={openScanner}\n      >\n        <Feather name=\"maximize\" size={24} color={Colors.dark.buttonText} />\n      </Pressable>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: Colors.dark.border,\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: \"700\",\n    color: Colors.dark.text,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 2,\n  },\n  addButton: {\n    width: 40,\n    height: 40,\n    borderRadius: BorderRadius.sm,\n    backgroundColor: Colors.dark.backgroundDefault,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n  },\n  addButtonPressed: {\n    borderColor: Colors.dark.primary,\n  },\n  list: {\n    flexGrow: 1,\n  },\n  sectionHeader: {\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    backgroundColor: Colors.dark.backgroundDefault,\n  },\n  sectionTitle: {\n    fontSize: 12,\n    color: Colors.dark.warning,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 0.5,\n  },\n  requestItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: Colors.dark.border,\n    backgroundColor: Colors.dark.backgroundDefault,\n  },\n  requestInfo: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    flex: 1,\n  },\n  requestText: {\n    marginLeft: Spacing.md,\n  },\n  requestName: {\n    fontSize: 15,\n    fontWeight: \"600\",\n    color: Colors.dark.text,\n    fontFamily: Fonts?.mono,\n  },\n  requestLabel: {\n    fontSize: 12,\n    color: Colors.dark.textSecondary,\n    fontFamily: Fonts?.mono,\n  },\n  requestActions: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  acceptButton: {\n    width: 36,\n    height: 36,\n    borderRadius: BorderRadius.sm,\n    backgroundColor: Colors.dark.secondary,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  rejectButton: {\n    width: 36,\n    height: 36,\n    borderRadius: BorderRadius.sm,\n    backgroundColor: Colors.dark.backgroundSecondary,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderWidth: 1,\n    borderColor: Colors.dark.danger,\n  },\n  buttonPressed: {\n    opacity: 0.7,\n  },\n  contactItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: Colors.dark.border,\n  },\n  contactTouchable: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    flex: 1,\n  },\n  contactItemPressed: {\n    opacity: 0.7,\n  },\n  avatarContainer: {\n    position: \"relative\",\n  },\n  avatar: {\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.sm,\n    backgroundColor: Colors.dark.backgroundSecondary,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n  },\n  avatarText: {\n    fontSize: 11,\n    fontWeight: \"600\",\n    color: Colors.dark.primary,\n    fontFamily: Fonts?.mono,\n  },\n  statusDot: {\n    position: \"absolute\",\n    bottom: -2,\n    right: -2,\n    width: 12,\n    height: 12,\n    borderRadius: 6,\n    backgroundColor: Colors.dark.offline,\n    borderWidth: 2,\n    borderColor: Colors.dark.backgroundRoot,\n  },\n  statusOnline: {\n    backgroundColor: Colors.dark.online,\n  },\n  deleteButton: {\n    width: 36,\n    height: 36,\n    borderRadius: BorderRadius.sm,\n    backgroundColor: Colors.dark.backgroundSecondary,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderWidth: 1,\n    borderColor: Colors.dark.danger,\n    marginLeft: Spacing.sm,\n  },\n  contactInfo: {\n    flex: 1,\n    marginLeft: Spacing.md,\n  },\n  contactName: {\n    fontSize: 15,\n    fontWeight: \"600\",\n    color: Colors.dark.text,\n    fontFamily: Fonts?.mono,\n    marginBottom: 2,\n  },\n  verifyRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n  },\n  verifiedText: {\n    fontSize: 11,\n    color: Colors.dark.secondary,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 0.5,\n  },\n  unverifiedText: {\n    fontSize: 11,\n    color: Colors.dark.warning,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 0.5,\n  },\n  emptyContainer: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingHorizontal: Spacing[\"2xl\"],\n    paddingTop: Spacing[\"5xl\"],\n  },\n  emptyIcon: {\n    width: 80,\n    height: 80,\n    borderRadius: BorderRadius.lg,\n    backgroundColor: Colors.dark.backgroundDefault,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    marginBottom: Spacing.xl,\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n  },\n  emptyTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    color: Colors.dark.textSecondary,\n    fontFamily: Fonts?.mono,\n    marginBottom: Spacing.sm,\n    letterSpacing: 1,\n  },\n  emptySubtitle: {\n    fontSize: 13,\n    color: Colors.dark.textTertiary,\n    fontFamily: Fonts?.mono,\n    textAlign: \"center\",\n  },\n  fab: {\n    position: \"absolute\",\n    right: Spacing.xl,\n    width: 56,\n    height: 56,\n    borderRadius: BorderRadius.full,\n    backgroundColor: Colors.dark.primary,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    shadowColor: Colors.dark.primary,\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.3,\n    shadowRadius: 4,\n    elevation: 4,\n  },\n  fabPressed: {\n    opacity: 0.8,\n    transform: [{ scale: 0.95 }],\n  },\n});\n","path":null,"size_bytes":16392,"size_tokens":null},"client/components/ErrorFallback.tsx":{"content":"import React, { useState } from \"react\";\nimport { reloadAppAsync } from \"expo\";\nimport {\n  StyleSheet,\n  View,\n  Pressable,\n  ScrollView,\n  Text,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\n\nexport type ErrorFallbackProps = {\n  error: Error;\n  resetError: () => void;\n};\n\nexport function ErrorFallback({ error, resetError }: ErrorFallbackProps) {\n  const { theme } = useTheme();\n  const [isModalVisible, setIsModalVisible] = useState(false);\n\n  const handleRestart = async () => {\n    try {\n      await reloadAppAsync();\n    } catch (restartError) {\n      console.error(\"Failed to restart app:\", restartError);\n      resetError();\n    }\n  };\n\n  const formatErrorDetails = (): string => {\n    let details = `Error: ${error.message}\\n\\n`;\n    if (error.stack) {\n      details += `Stack Trace:\\n${error.stack}`;\n    }\n    return details;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      {__DEV__ ? (\n        <Pressable\n          onPress={() => setIsModalVisible(true)}\n          style={({ pressed }) => [\n            styles.topButton,\n            {\n              backgroundColor: theme.backgroundDefault,\n              opacity: pressed ? 0.8 : 1,\n            },\n          ]}\n        >\n          <Feather name=\"alert-circle\" size={20} color={theme.text} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.content}>\n        <ThemedText type=\"h1\" style={styles.title}>\n          Something went wrong\n        </ThemedText>\n\n        <ThemedText type=\"body\" style={styles.message}>\n          Please reload the app to continue.\n        </ThemedText>\n\n        <Pressable\n          onPress={handleRestart}\n          style={({ pressed }) => [\n            styles.button,\n            {\n              backgroundColor: theme.link,\n              opacity: pressed ? 0.9 : 1,\n              transform: [{ scale: pressed ? 0.98 : 1 }],\n            },\n          ]}\n        >\n          <ThemedText\n            type=\"body\"\n            style={[styles.buttonText, { color: theme.buttonText }]}\n          >\n            Try Again\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      {__DEV__ ? (\n        <Modal\n          visible={isModalVisible}\n          animationType=\"slide\"\n          transparent={true}\n          onRequestClose={() => setIsModalVisible(false)}\n        >\n          <View style={styles.modalOverlay}>\n            <ThemedView style={styles.modalContainer}>\n              <View style={styles.modalHeader}>\n                <ThemedText type=\"h2\" style={styles.modalTitle}>\n                  Error Details\n                </ThemedText>\n                <Pressable\n                  onPress={() => setIsModalVisible(false)}\n                  style={({ pressed }) => [\n                    styles.closeButton,\n                    { opacity: pressed ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"x\" size={24} color={theme.text} />\n                </Pressable>\n              </View>\n\n              <ScrollView\n                style={styles.modalScrollView}\n                contentContainerStyle={styles.modalScrollContent}\n                showsVerticalScrollIndicator\n              >\n                <View\n                  style={[\n                    styles.errorContainer,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <Text\n                    style={[\n                      styles.errorText,\n                      {\n                        color: theme.text,\n                        fontFamily: Fonts?.mono || \"monospace\",\n                      },\n                    ]}\n                    selectable\n                  >\n                    {formatErrorDetails()}\n                  </Text>\n                </View>\n              </ScrollView>\n            </ThemedView>\n          </View>\n        </Modal>\n      ) : null}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    width: \"100%\",\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing[\"2xl\"],\n  },\n  content: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    width: \"100%\",\n    maxWidth: 600,\n  },\n  title: {\n    textAlign: \"center\",\n    lineHeight: 40,\n  },\n  message: {\n    textAlign: \"center\",\n    opacity: 0.7,\n    lineHeight: 24,\n  },\n  topButton: {\n    position: \"absolute\",\n    top: Spacing[\"2xl\"] + Spacing.lg,\n    right: Spacing.lg,\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.md,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 10,\n  },\n  button: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    paddingHorizontal: Spacing[\"2xl\"],\n    minWidth: 200,\n    shadowColor: \"#000\",\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    fontSize: 16,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContainer: {\n    width: \"100%\",\n    height: \"90%\",\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(128, 128, 128, 0.2)\",\n  },\n  modalTitle: {\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  modalScrollView: {\n    flex: 1,\n  },\n  modalScrollContent: {\n    padding: Spacing.lg,\n  },\n  errorContainer: {\n    width: \"100%\",\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    padding: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 12,\n    lineHeight: 18,\n    width: \"100%\",\n  },\n});\n","path":null,"size_bytes":6194,"size_tokens":null},"replit.md":{"content":"# Watchdog Messenger\n\n## Overview\n\nWatchdog is a privacy-focused encrypted messaging application built with React Native (Expo) for cross-platform mobile/web support and an Express.js backend. The app emphasizes military-grade encryption using the TweetNaCl library for end-to-end encrypted communications, with features like self-destructing messages, contact verification via safety numbers, and QR code-based contact pairing.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: React Native with Expo SDK 54 for cross-platform (iOS, Android, Web) support\n- **Navigation**: React Navigation v7 with a hybrid structure:\n  - Native Stack Navigator for root-level screens (Register, Chat, Scanner, VerifyContact)\n  - Bottom Tab Navigator for main app tabs (Chats, Contacts, Profile)\n- **State Management**: \n  - TanStack React Query for server state and API caching\n  - React Context (AuthContext) for authentication state\n- **Styling**: Custom theming system with dark terminal-inspired aesthetic (cyan/green accent colors)\n- **Animations**: React Native Reanimated for smooth UI interactions\n\n### Backend Architecture\n- **Runtime**: Node.js with Express.js\n- **Real-time Communication**: Socket.io for instant messaging, typing indicators, and online status\n- **API Structure**: RESTful endpoints under `/api/` prefix with corresponding socket events for real-time features\n- **Database ORM**: Drizzle ORM with PostgreSQL\n\n### Security & Encryption\n- **Encryption Library**: TweetNaCl (NaCl) for public-key cryptography\n- **Key Generation**: Automatic generation of identity key pairs and signed pre-keys during registration\n- **Message Encryption**: Box encryption using recipient's public key and sender's secret key\n- **Safety Numbers**: Generated from combined public keys for contact verification\n- **Self-Destructing Messages**: Optional timed message deletion (30s to 1h options)\n\n### Data Storage\n- **Server-side**: PostgreSQL with Drizzle ORM\n  - Users table: stores credentials, public keys, pairing codes, online status\n  - Contacts table: stores contact relationships and verification status\n  - Messages table: stores encrypted message content with delivery/read status\n  - Contact Requests table: handles pending contact additions\n- **Client-side**: AsyncStorage (native) / localStorage (web) for:\n  - User session data\n  - Private encryption keys\n  - App settings (encryption toggle, self-destruct timer)\n\n### Path Aliases\n- `@/` maps to `./client/` for frontend code\n- `@shared/` maps to `./shared/` for shared types and schemas\n\n## External Dependencies\n\n### Database\n- PostgreSQL (required, configured via `DATABASE_URL` environment variable)\n- Drizzle ORM for type-safe database operations\n\n### Real-time Communication\n- Socket.io for WebSocket-based messaging\n\n### Cryptography\n- TweetNaCl for end-to-end encryption\n- tweetnacl-util for encoding/decoding utilities\n\n### UI/UX Libraries\n- Expo SDK modules (blur, haptics, image, splash-screen)\n- React Native Gesture Handler and Reanimated for animations\n- Expo Vector Icons (Feather icon set)\n\n### Build & Development\n- Expo CLI for development and builds\n- TypeScript for type safety\n- ESLint + Prettier for code quality","path":null,"size_bytes":3288,"size_tokens":null},"client/App.tsx":{"content":"import React from \"react\";\nimport { StyleSheet } from \"react-native\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { KeyboardProvider } from \"react-native-keyboard-controller\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { StatusBar } from \"expo-status-bar\";\n\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { queryClient } from \"@/lib/query-client\";\n\nimport RootStackNavigator from \"@/navigation/RootStackNavigator\";\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\nimport { AuthProvider } from \"@/context/AuthContext\";\n\nexport default function App() {\n  return (\n    <ErrorBoundary>\n      <QueryClientProvider client={queryClient}>\n        <SafeAreaProvider>\n          <GestureHandlerRootView style={styles.root}>\n            <KeyboardProvider>\n              <AuthProvider>\n                <NavigationContainer>\n                  <RootStackNavigator />\n                </NavigationContainer>\n              </AuthProvider>\n              <StatusBar style=\"light\" />\n            </KeyboardProvider>\n          </GestureHandlerRootView>\n        </SafeAreaProvider>\n      </QueryClientProvider>\n    </ErrorBoundary>\n  );\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n    backgroundColor: \"#0A0E14\",\n  },\n});\n","path":null,"size_bytes":1377,"size_tokens":null},"client/screens/ChatsScreen.tsx":{"content":"import React, { useEffect, useState, useCallback } from \"react\";\nimport {\n  View,\n  FlatList,\n  StyleSheet,\n  Pressable,\n  RefreshControl,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Colors, Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Feather } from \"@expo/vector-icons\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { getSocket } from \"@/lib/socket\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\ninterface Contact {\n  id: string;\n  userId: string;\n  contactId: string;\n  status: string;\n  isVerified: boolean;\n  contact: {\n    id: string;\n    username: string;\n    publicKey: string;\n    isOnline: boolean;\n    lastSeen: string;\n  };\n}\n\nexport default function ChatsScreen() {\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useBottomTabBarHeight();\n  const navigation = useNavigation<NavigationProp>();\n  const { user } = useAuth();\n  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());\n\n  const { data: contacts, isLoading, refetch } = useQuery<Contact[]>({\n    queryKey: [\"/api/contacts\", user?.id],\n    enabled: !!user?.id,\n  });\n\n  useEffect(() => {\n    const socket = getSocket();\n    \n    const handleUserStatus = ({ userId, isOnline }: { userId: string; isOnline: boolean }) => {\n      setOnlineUsers(prev => {\n        const next = new Set(prev);\n        if (isOnline) {\n          next.add(userId);\n        } else {\n          next.delete(userId);\n        }\n        return next;\n      });\n    };\n\n    socket.on(\"user:status\", handleUserStatus);\n\n    return () => {\n      socket.off(\"user:status\", handleUserStatus);\n    };\n  }, []);\n\n  const openChat = useCallback((contact: Contact) => {\n    navigation.navigate(\"Chat\", {\n      contactId: contact.contactId,\n      contactName: contact.contact.username,\n      contactPublicKey: contact.contact.publicKey,\n    });\n  }, [navigation]);\n\n  const openScanner = useCallback(() => {\n    navigation.navigate(\"Scanner\");\n  }, [navigation]);\n\n  const renderItem = useCallback(({ item }: { item: Contact }) => {\n    const isOnline = onlineUsers.has(item.contactId) || item.contact.isOnline;\n    \n    return (\n      <Pressable\n        style={({ pressed }) => [\n          styles.chatItem,\n          pressed && styles.chatItemPressed,\n        ]}\n        onPress={() => openChat(item)}\n      >\n        <View style={styles.avatarContainer}>\n          <View style={styles.avatar}>\n            <ThemedText style={styles.avatarText}>\n              [{item.contact.username.substring(0, 2).toUpperCase()}]\n            </ThemedText>\n          </View>\n          <View style={[styles.statusDot, isOnline && styles.statusOnline]} />\n        </View>\n        \n        <View style={styles.chatInfo}>\n          <View style={styles.chatHeader}>\n            <ThemedText style={styles.contactName}>\n              {item.contact.username}\n            </ThemedText>\n            {item.isVerified ? (\n              <Feather name=\"check-circle\" size={14} color={Colors.dark.secondary} />\n            ) : (\n              <Feather name=\"alert-triangle\" size={14} color={Colors.dark.warning} />\n            )}\n          </View>\n          <View style={styles.chatPreview}>\n            <Feather name=\"lock\" size={12} color={Colors.dark.secondary} />\n            <ThemedText style={styles.previewText} numberOfLines={1}>\n              Encrypted conversation\n            </ThemedText>\n          </View>\n        </View>\n        \n        <Feather name=\"chevron-right\" size={18} color={Colors.dark.textTertiary} />\n      </Pressable>\n    );\n  }, [onlineUsers, openChat]);\n\n  const renderEmpty = useCallback(() => (\n    <View style={styles.emptyContainer}>\n      <View style={styles.emptyIcon}>\n        <Feather name=\"message-square\" size={48} color={Colors.dark.textTertiary} />\n      </View>\n      <ThemedText style={styles.emptyTitle}>NO ACTIVE CHATS</ThemedText>\n      <ThemedText style={styles.emptySubtitle}>\n        $ Scan a QR code or enter a pairing code to connect with someone\n      </ThemedText>\n      <Pressable\n        style={({ pressed }) => [styles.scanButton, pressed && styles.scanButtonPressed]}\n        onPress={openScanner}\n      >\n        <Feather name=\"maximize\" size={18} color={Colors.dark.buttonText} />\n        <ThemedText style={styles.scanButtonText}>SCAN QR CODE</ThemedText>\n      </Pressable>\n    </View>\n  ), [openScanner]);\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <View style={styles.titleRow}>\n          <Feather name=\"shield\" size={24} color={Colors.dark.primary} />\n          <ThemedText style={styles.title}>WATCHDOG</ThemedText>\n        </View>\n        <Pressable\n          style={({ pressed }) => [styles.iconButton, pressed && styles.iconButtonPressed]}\n          onPress={openScanner}\n        >\n          <Feather name=\"maximize\" size={22} color={Colors.dark.primary} />\n        </Pressable>\n      </View>\n\n      <FlatList\n        data={contacts?.filter(c => c.status === \"accepted\") || []}\n        keyExtractor={(item) => item.id}\n        renderItem={renderItem}\n        ListEmptyComponent={renderEmpty}\n        contentContainerStyle={[\n          styles.list,\n          { paddingBottom: tabBarHeight + Spacing.xl },\n        ]}\n        refreshControl={\n          <RefreshControl\n            refreshing={isLoading}\n            onRefresh={refetch}\n            tintColor={Colors.dark.primary}\n          />\n        }\n      />\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: Colors.dark.border,\n  },\n  titleRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: \"700\",\n    color: Colors.dark.primary,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 2,\n  },\n  iconButton: {\n    width: 40,\n    height: 40,\n    borderRadius: BorderRadius.sm,\n    backgroundColor: Colors.dark.backgroundDefault,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n  },\n  iconButtonPressed: {\n    borderColor: Colors.dark.primary,\n  },\n  list: {\n    flexGrow: 1,\n    paddingTop: Spacing.sm,\n  },\n  chatItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: Colors.dark.border,\n  },\n  chatItemPressed: {\n    backgroundColor: Colors.dark.backgroundDefault,\n  },\n  avatarContainer: {\n    position: \"relative\",\n    marginRight: Spacing.md,\n  },\n  avatar: {\n    width: 48,\n    height: 48,\n    borderRadius: BorderRadius.sm,\n    backgroundColor: Colors.dark.backgroundSecondary,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n  },\n  avatarText: {\n    fontSize: 12,\n    fontWeight: \"600\",\n    color: Colors.dark.primary,\n    fontFamily: Fonts?.mono,\n  },\n  statusDot: {\n    position: \"absolute\",\n    bottom: -2,\n    right: -2,\n    width: 14,\n    height: 14,\n    borderRadius: 7,\n    backgroundColor: Colors.dark.offline,\n    borderWidth: 2,\n    borderColor: Colors.dark.backgroundRoot,\n  },\n  statusOnline: {\n    backgroundColor: Colors.dark.online,\n  },\n  chatInfo: {\n    flex: 1,\n  },\n  chatHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n    marginBottom: Spacing.xs,\n  },\n  contactName: {\n    fontSize: 15,\n    fontWeight: \"600\",\n    color: Colors.dark.text,\n    fontFamily: Fonts?.mono,\n  },\n  chatPreview: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n  },\n  previewText: {\n    fontSize: 13,\n    color: Colors.dark.textSecondary,\n    fontFamily: Fonts?.mono,\n  },\n  emptyContainer: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingHorizontal: Spacing[\"2xl\"],\n    paddingTop: Spacing[\"5xl\"],\n  },\n  emptyIcon: {\n    width: 80,\n    height: 80,\n    borderRadius: BorderRadius.lg,\n    backgroundColor: Colors.dark.backgroundDefault,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    marginBottom: Spacing.xl,\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n  },\n  emptyTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    color: Colors.dark.textSecondary,\n    fontFamily: Fonts?.mono,\n    marginBottom: Spacing.sm,\n    letterSpacing: 1,\n  },\n  emptySubtitle: {\n    fontSize: 13,\n    color: Colors.dark.textTertiary,\n    fontFamily: Fonts?.mono,\n    textAlign: \"center\",\n    marginBottom: Spacing.xl,\n    lineHeight: 20,\n  },\n  scanButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    backgroundColor: Colors.dark.primary,\n    paddingHorizontal: Spacing.xl,\n    height: 44,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  scanButtonPressed: {\n    opacity: 0.8,\n  },\n  scanButtonText: {\n    fontSize: 13,\n    fontWeight: \"600\",\n    color: Colors.dark.buttonText,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 0.5,\n  },\n});\n","path":null,"size_bytes":9743,"size_tokens":null},"eslint.config.js":{"content":"// https://docs.expo.dev/guides/using-eslint/\nconst { defineConfig } = require(\"eslint/config\");\nconst expoConfig = require(\"eslint-config-expo/flat\");\nconst eslintPluginPrettierRecommended = require(\"eslint-plugin-prettier/recommended\");\n\nmodule.exports = defineConfig([\n  expoConfig,\n  eslintPluginPrettierRecommended,\n  {\n    ignores: [\"dist/*\"],\n  },\n]);\n","path":null,"size_bytes":359,"size_tokens":null},"client/components/Card.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable, ViewStyle } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CardProps {\n  elevation?: number;\n  title?: string;\n  description?: string;\n  children?: React.ReactNode;\n  onPress?: () => void;\n  style?: ViewStyle;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst getBackgroundColorForElevation = (\n  elevation: number,\n  theme: any,\n): string => {\n  switch (elevation) {\n    case 1:\n      return theme.backgroundDefault;\n    case 2:\n      return theme.backgroundSecondary;\n    case 3:\n      return theme.backgroundTertiary;\n    default:\n      return theme.backgroundRoot;\n  }\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Card({\n  elevation = 1,\n  title,\n  description,\n  children,\n  onPress,\n  style,\n}: CardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const cardBackgroundColor = getBackgroundColorForElevation(elevation, theme);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.98, springConfig);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, springConfig);\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.card,\n        {\n          backgroundColor: cardBackgroundColor,\n        },\n        animatedStyle,\n        style,\n      ]}\n    >\n      {title ? (\n        <ThemedText type=\"h4\" style={styles.cardTitle}>\n          {title}\n        </ThemedText>\n      ) : null}\n      {description ? (\n        <ThemedText type=\"small\" style={styles.cardDescription}>\n          {description}\n        </ThemedText>\n      ) : null}\n      {children}\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius[\"2xl\"],\n  },\n  cardTitle: {\n    marginBottom: Spacing.sm,\n  },\n  cardDescription: {\n    opacity: 0.7,\n  },\n});\n","path":null,"size_bytes":2437,"size_tokens":null},"client/screens/VerifyContactScreen.tsx":{"content":"import React, { useMemo, useCallback } from \"react\";\nimport { View, ScrollView, StyleSheet, Pressable } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useRoute, useNavigation } from \"@react-navigation/native\";\nimport type { RouteProp } from \"@react-navigation/native\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Colors, Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Feather } from \"@expo/vector-icons\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { generateSafetyNumber } from \"@/lib/crypto\";\nimport * as Haptics from \"expo-haptics\";\nimport { getApiUrl } from \"@/lib/query-client\";\n\ntype VerifyRouteProp = RouteProp<RootStackParamList, \"VerifyContact\">;\n\nexport default function VerifyContactScreen() {\n  const insets = useSafeAreaInsets();\n  const route = useRoute<VerifyRouteProp>();\n  const navigation = useNavigation();\n  const { contactName, contactPublicKey } = route.params;\n  const { user } = useAuth();\n\n  const safetyNumber = useMemo(() => {\n    if (!user?.publicKey || !contactPublicKey) return \"\";\n    return generateSafetyNumber(user.publicKey, contactPublicKey);\n  }, [user?.publicKey, contactPublicKey]);\n\n  const handleVerify = useCallback(async () => {\n    try {\n      const { contactId } = route.params;\n      await fetch(`${getApiUrl()}/api/contacts/${contactId}/verify`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ \n          userId: user?.id,\n          isVerified: true, \n          safetyNumber \n        }),\n      });\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      navigation.goBack();\n    } catch (error) {\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n    }\n  }, [navigation, route.params, user?.id, safetyNumber]);\n\n  return (\n    <ThemedView style={styles.container}>\n      <ScrollView\n        contentContainerStyle={[styles.content, { paddingBottom: insets.bottom + Spacing.xl }]}\n        showsVerticalScrollIndicator={false}\n      >\n        <View style={styles.header}>\n          <View style={styles.iconContainer}>\n            <Feather name=\"shield\" size={32} color={Colors.dark.secondary} />\n          </View>\n          <ThemedText style={styles.title}>VERIFY {contactName.toUpperCase()}</ThemedText>\n          <ThemedText style={styles.subtitle}>\n            Compare this safety number with {contactName} to ensure your conversation is secure\n          </ThemedText>\n        </View>\n\n        <View style={styles.safetyNumberContainer}>\n          <ThemedText style={styles.safetyLabel}>SAFETY NUMBER</ThemedText>\n          <View style={styles.numberGrid}>\n            {safetyNumber.split(\" \").map((group, index) => (\n              <View key={index} style={styles.numberGroup}>\n                <ThemedText style={styles.numberText}>{group}</ThemedText>\n              </View>\n            ))}\n          </View>\n        </View>\n\n        <View style={styles.instructionsContainer}>\n          <ThemedText style={styles.instructionsTitle}>$ HOW TO VERIFY</ThemedText>\n          <View style={styles.instruction}>\n            <ThemedText style={styles.instructionNumber}>1.</ThemedText>\n            <ThemedText style={styles.instructionText}>\n              Meet with {contactName} in person or via a secure video call\n            </ThemedText>\n          </View>\n          <View style={styles.instruction}>\n            <ThemedText style={styles.instructionNumber}>2.</ThemedText>\n            <ThemedText style={styles.instructionText}>\n              Ask them to open this verification screen on their device\n            </ThemedText>\n          </View>\n          <View style={styles.instruction}>\n            <ThemedText style={styles.instructionNumber}>3.</ThemedText>\n            <ThemedText style={styles.instructionText}>\n              Compare the safety numbers on both devices - they should match exactly\n            </ThemedText>\n          </View>\n          <View style={styles.instruction}>\n            <ThemedText style={styles.instructionNumber}>4.</ThemedText>\n            <ThemedText style={styles.instructionText}>\n              If they match, tap \"Mark as Verified\" below\n            </ThemedText>\n          </View>\n        </View>\n\n        <View style={styles.warningBox}>\n          <Feather name=\"alert-triangle\" size={14} color={Colors.dark.warning} />\n          <ThemedText style={styles.warningText}>\n            If the numbers do not match, do not proceed. Your conversation may be compromised.\n          </ThemedText>\n        </View>\n\n        <Pressable\n          style={({ pressed }) => [styles.verifyButton, pressed && styles.verifyButtonPressed]}\n          onPress={handleVerify}\n        >\n          <Feather name=\"check-circle\" size={18} color={Colors.dark.buttonText} />\n          <ThemedText style={styles.verifyButtonText}>MARK AS VERIFIED</ThemedText>\n        </Pressable>\n      </ScrollView>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, backgroundColor: Colors.dark.backgroundRoot },\n  content: { paddingHorizontal: Spacing.lg, paddingTop: Spacing.xl },\n  header: { alignItems: \"center\", marginBottom: Spacing[\"2xl\"] },\n  iconContainer: { width: 64, height: 64, borderRadius: BorderRadius.lg, backgroundColor: Colors.dark.backgroundDefault, borderWidth: 1, borderColor: Colors.dark.secondary, justifyContent: \"center\", alignItems: \"center\", marginBottom: Spacing.lg },\n  title: { fontSize: 18, fontWeight: \"700\", color: Colors.dark.text, fontFamily: Fonts?.mono, letterSpacing: 1, marginBottom: Spacing.sm, textAlign: \"center\" },\n  subtitle: { fontSize: 13, color: Colors.dark.textSecondary, fontFamily: Fonts?.mono, textAlign: \"center\", lineHeight: 20 },\n  safetyNumberContainer: { backgroundColor: Colors.dark.backgroundDefault, borderRadius: BorderRadius.md, borderWidth: 1, borderColor: Colors.dark.border, padding: Spacing.lg, marginBottom: Spacing.xl },\n  safetyLabel: { fontSize: 10, color: Colors.dark.textSecondary, fontFamily: Fonts?.mono, letterSpacing: 1, marginBottom: Spacing.md, textAlign: \"center\" },\n  numberGrid: { flexDirection: \"row\", flexWrap: \"wrap\", justifyContent: \"center\", gap: Spacing.sm },\n  numberGroup: { backgroundColor: Colors.dark.backgroundSecondary, paddingHorizontal: Spacing.sm, paddingVertical: Spacing.xs, borderRadius: BorderRadius.xs },\n  numberText: { fontSize: 12, fontWeight: \"600\", color: Colors.dark.primary, fontFamily: Fonts?.mono, letterSpacing: 1 },\n  instructionsContainer: { marginBottom: Spacing.xl },\n  instructionsTitle: { fontSize: 12, color: Colors.dark.secondary, fontFamily: Fonts?.mono, letterSpacing: 0.5, marginBottom: Spacing.md },\n  instruction: { flexDirection: \"row\", marginBottom: Spacing.md },\n  instructionNumber: { fontSize: 13, color: Colors.dark.primary, fontFamily: Fonts?.mono, width: 20 },\n  instructionText: { flex: 1, fontSize: 13, color: Colors.dark.text, fontFamily: Fonts?.mono, lineHeight: 20 },\n  warningBox: { flexDirection: \"row\", alignItems: \"flex-start\", backgroundColor: Colors.dark.backgroundDefault, borderWidth: 1, borderColor: Colors.dark.warning, borderRadius: BorderRadius.sm, padding: Spacing.md, gap: Spacing.sm, marginBottom: Spacing.xl },\n  warningText: { flex: 1, fontSize: 12, color: Colors.dark.warning, fontFamily: Fonts?.mono, lineHeight: 18 },\n  verifyButton: { flexDirection: \"row\", alignItems: \"center\", justifyContent: \"center\", backgroundColor: Colors.dark.secondary, height: Spacing.buttonHeight, borderRadius: BorderRadius.sm, gap: Spacing.sm },\n  verifyButtonPressed: { opacity: 0.8 },\n  verifyButtonText: { fontSize: 14, fontWeight: \"600\", color: Colors.dark.buttonText, fontFamily: Fonts?.mono, letterSpacing: 1 },\n});\n","path":null,"size_bytes":7894,"size_tokens":null},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { Server as SocketServer } from \"socket.io\";\nimport { storage } from \"./storage\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst connectedUsers = new Map<string, string>();\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  const httpServer = createServer(app);\n  \n  const io = new SocketServer(httpServer, {\n    cors: {\n      origin: \"*\",\n      methods: [\"GET\", \"POST\"],\n    },\n  });\n\n  io.on(\"connection\", (socket) => {\n    console.log(\"Client connected:\", socket.id);\n    \n    socket.on(\"user:online\", async (userId: string) => {\n      connectedUsers.set(userId, socket.id);\n      await storage.updateUserOnlineStatus(userId, true);\n      io.emit(\"user:status\", { userId, isOnline: true });\n    });\n\n    socket.on(\"message:send\", async (data: {\n      senderId: string;\n      recipientId: string;\n      encryptedContent: string;\n      nonce: string;\n      isEncrypted: boolean;\n      selfDestructSeconds?: number;\n    }) => {\n      try {\n        const message = await storage.createMessage(data);\n        \n        const recipientSocketId = connectedUsers.get(data.recipientId);\n        if (recipientSocketId) {\n          io.to(recipientSocketId).emit(\"message:receive\", message);\n          await storage.markMessageAsDelivered(message.id);\n        }\n        \n        socket.emit(\"message:sent\", message);\n      } catch (error) {\n        socket.emit(\"message:error\", { error: \"Failed to send message\" });\n      }\n    });\n\n    socket.on(\"message:read\", async (messageId: string) => {\n      await storage.markMessageAsRead(messageId);\n    });\n\n    socket.on(\"message:typing\", (data: { senderId: string; recipientId: string }) => {\n      const recipientSocketId = connectedUsers.get(data.recipientId);\n      if (recipientSocketId) {\n        io.to(recipientSocketId).emit(\"message:typing\", { senderId: data.senderId });\n      }\n    });\n\n    socket.on(\"contact:request\", async (data: { fromUserId: string; toUserId: string }) => {\n      try {\n        const existing = await storage.getContactRequest(data.fromUserId, data.toUserId);\n        if (existing) {\n          socket.emit(\"contact:request:error\", { error: \"Request already sent\" });\n          return;\n        }\n        \n        const request = await storage.createContactRequest(data);\n        const fromUser = await storage.getUser(data.fromUserId);\n        \n        const recipientSocketId = connectedUsers.get(data.toUserId);\n        if (recipientSocketId && fromUser) {\n          io.to(recipientSocketId).emit(\"contact:request:received\", {\n            ...request,\n            fromUser,\n          });\n        }\n        \n        socket.emit(\"contact:request:sent\", request);\n      } catch (error) {\n        socket.emit(\"contact:request:error\", { error: \"Failed to send request\" });\n      }\n    });\n\n    socket.on(\"contact:accept\", async (data: { requestId: string; userId: string; contactId: string }) => {\n      try {\n        await storage.updateContactRequestStatus(data.requestId, \"accepted\");\n        \n        await storage.createContact({\n          userId: data.userId,\n          contactId: data.contactId,\n          status: \"accepted\",\n        });\n        await storage.createContact({\n          userId: data.contactId,\n          contactId: data.userId,\n          status: \"accepted\",\n        });\n        \n        const user = await storage.getUser(data.userId);\n        const contact = await storage.getUser(data.contactId);\n        \n        const contactSocketId = connectedUsers.get(data.contactId);\n        if (contactSocketId && user) {\n          io.to(contactSocketId).emit(\"contact:accepted\", {\n            contact: user,\n          });\n        }\n        \n        socket.emit(\"contact:accepted\", { contact });\n      } catch (error) {\n        socket.emit(\"contact:error\", { error: \"Failed to accept request\" });\n      }\n    });\n\n    socket.on(\"contact:reject\", async (data: { requestId: string }) => {\n      await storage.updateContactRequestStatus(data.requestId, \"rejected\");\n    });\n\n    socket.on(\"contact:delete\", async (data: { userId: string; contactId: string }) => {\n      try {\n        await storage.deleteContact(data.userId, data.contactId);\n        \n        const contactSocketId = connectedUsers.get(data.contactId);\n        if (contactSocketId) {\n          io.to(contactSocketId).emit(\"contact:deleted\", { deletedBy: data.userId });\n        }\n        \n        socket.emit(\"contact:deleted:success\", { contactId: data.contactId });\n      } catch (error) {\n        socket.emit(\"contact:error\", { error: \"Failed to delete contact\" });\n      }\n    });\n\n    socket.on(\"disconnect\", async () => {\n      for (const [userId, socketId] of connectedUsers.entries()) {\n        if (socketId === socket.id) {\n          connectedUsers.delete(userId);\n          await storage.updateUserOnlineStatus(userId, false);\n          io.emit(\"user:status\", { userId, isOnline: false });\n          break;\n        }\n      }\n      console.log(\"Client disconnected:\", socket.id);\n    });\n  });\n\n  app.post(\"/api/auth/register\", async (req, res) => {\n    try {\n      const { username, publicKey, identityKey, signedPreKey } = req.body;\n      \n      const existing = await storage.getUserByUsername(username);\n      if (existing) {\n        return res.status(400).json({ error: \"Username already taken\" });\n      }\n      \n      const pairingCode = uuidv4().slice(0, 8).toUpperCase();\n      \n      const user = await storage.createUser({\n        username,\n        publicKey,\n        identityKey,\n        signedPreKey,\n        pairingCode,\n      });\n      \n      res.json(user);\n    } catch (error) {\n      console.error(\"Registration error:\", error);\n      res.status(500).json({ error: \"Failed to register\" });\n    }\n  });\n\n  app.post(\"/api/auth/login\", async (req, res) => {\n    try {\n      const { username } = req.body;\n      \n      const user = await storage.getUserByUsername(username);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      \n      res.json(user);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to login\" });\n    }\n  });\n\n  app.get(\"/api/users/:id\", async (req, res) => {\n    try {\n      const user = await storage.getUser(req.params.id);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      res.json(user);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get user\" });\n    }\n  });\n\n  app.get(\"/api/users/code/:code\", async (req, res) => {\n    try {\n      const user = await storage.getUserByPairingCode(req.params.code.toUpperCase());\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      res.json(user);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get user\" });\n    }\n  });\n\n  app.get(\"/api/contacts/:userId\", async (req, res) => {\n    try {\n      const contacts = await storage.getContacts(req.params.userId);\n      res.json(contacts);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get contacts\" });\n    }\n  });\n\n  app.get(\"/api/messages/:userId/:contactId\", async (req, res) => {\n    try {\n      const messages = await storage.getMessages(req.params.userId, req.params.contactId);\n      res.json(messages);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get messages\" });\n    }\n  });\n\n  app.get(\"/api/contact-requests/:userId\", async (req, res) => {\n    try {\n      const requests = await storage.getContactRequests(req.params.userId);\n      res.json(requests);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get contact requests\" });\n    }\n  });\n\n  app.delete(\"/api/messages/:messageId\", async (req, res) => {\n    try {\n      await storage.deleteMessage(req.params.messageId);\n      res.json({ success: true });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to delete message\" });\n    }\n  });\n\n  app.post(\"/api/contacts/:contactId/verify\", async (req, res) => {\n    try {\n      const { userId, isVerified, safetyNumber } = req.body;\n      const contact = await storage.getContact(userId, req.params.contactId);\n      if (!contact) {\n        return res.status(404).json({ error: \"Contact not found\" });\n      }\n      await storage.updateContactVerification(contact.id, isVerified, safetyNumber);\n      res.json({ success: true });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to verify contact\" });\n    }\n  });\n\n  setInterval(async () => {\n    try {\n      const expired = await storage.getExpiredMessages();\n      for (const msg of expired) {\n        if (msg.selfDestructAt && new Date() > msg.selfDestructAt) {\n          await storage.deleteMessage(msg.id);\n        }\n      }\n    } catch (error) {\n      console.error(\"Self-destruct cleanup error:\", error);\n    }\n  }, 60000);\n\n  return httpServer;\n}\n","path":null,"size_bytes":8901,"size_tokens":null},"shared/schema.ts":{"content":"import { sql, relations } from \"drizzle-orm\";\nimport { pgTable, text, varchar, timestamp, boolean, integer } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const users = pgTable(\"users\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  username: text(\"username\").notNull().unique(),\n  publicKey: text(\"public_key\").notNull(),\n  identityKey: text(\"identity_key\").notNull(),\n  signedPreKey: text(\"signed_pre_key\").notNull(),\n  pairingCode: text(\"pairing_code\").notNull().unique(),\n  isOnline: boolean(\"is_online\").default(false),\n  lastSeen: timestamp(\"last_seen\").defaultNow(),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n});\n\nexport const usersRelations = relations(users, ({ many }) => ({\n  sentContacts: many(contacts, { relationName: \"sentContacts\" }),\n  receivedContacts: many(contacts, { relationName: \"receivedContacts\" }),\n  sentMessages: many(messages, { relationName: \"sentMessages\" }),\n  receivedMessages: many(messages, { relationName: \"receivedMessages\" }),\n}));\n\nexport const contacts = pgTable(\"contacts\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  userId: varchar(\"user_id\").notNull().references(() => users.id),\n  contactId: varchar(\"contact_id\").notNull().references(() => users.id),\n  status: text(\"status\").notNull().default(\"pending\"),\n  isVerified: boolean(\"is_verified\").default(false),\n  safetyNumber: text(\"safety_number\"),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  updatedAt: timestamp(\"updated_at\").defaultNow(),\n});\n\nexport const contactsRelations = relations(contacts, ({ one }) => ({\n  user: one(users, {\n    fields: [contacts.userId],\n    references: [users.id],\n    relationName: \"sentContacts\",\n  }),\n  contact: one(users, {\n    fields: [contacts.contactId],\n    references: [users.id],\n    relationName: \"receivedContacts\",\n  }),\n}));\n\nexport const messages = pgTable(\"messages\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  senderId: varchar(\"sender_id\").notNull().references(() => users.id),\n  recipientId: varchar(\"recipient_id\").notNull().references(() => users.id),\n  encryptedContent: text(\"encrypted_content\").notNull(),\n  nonce: text(\"nonce\").notNull(),\n  isEncrypted: boolean(\"is_encrypted\").default(true),\n  isRead: boolean(\"is_read\").default(false),\n  isDelivered: boolean(\"is_delivered\").default(false),\n  selfDestructAt: timestamp(\"self_destruct_at\"),\n  selfDestructSeconds: integer(\"self_destruct_seconds\"),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  deletedAt: timestamp(\"deleted_at\"),\n});\n\nexport const messagesRelations = relations(messages, ({ one }) => ({\n  sender: one(users, {\n    fields: [messages.senderId],\n    references: [users.id],\n    relationName: \"sentMessages\",\n  }),\n  recipient: one(users, {\n    fields: [messages.recipientId],\n    references: [users.id],\n    relationName: \"receivedMessages\",\n  }),\n}));\n\nexport const contactRequests = pgTable(\"contact_requests\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  fromUserId: varchar(\"from_user_id\").notNull().references(() => users.id),\n  toUserId: varchar(\"to_user_id\").notNull().references(() => users.id),\n  status: text(\"status\").notNull().default(\"pending\"),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  respondedAt: timestamp(\"responded_at\"),\n});\n\nexport const contactRequestsRelations = relations(contactRequests, ({ one }) => ({\n  fromUser: one(users, {\n    fields: [contactRequests.fromUserId],\n    references: [users.id],\n  }),\n  toUser: one(users, {\n    fields: [contactRequests.toUserId],\n    references: [users.id],\n  }),\n}));\n\nexport const insertUserSchema = createInsertSchema(users).pick({\n  username: true,\n  publicKey: true,\n  identityKey: true,\n  signedPreKey: true,\n  pairingCode: true,\n});\n\nexport const insertContactSchema = createInsertSchema(contacts).pick({\n  userId: true,\n  contactId: true,\n  status: true,\n});\n\nexport const insertMessageSchema = createInsertSchema(messages).pick({\n  senderId: true,\n  recipientId: true,\n  encryptedContent: true,\n  nonce: true,\n  isEncrypted: true,\n  selfDestructSeconds: true,\n});\n\nexport const insertContactRequestSchema = createInsertSchema(contactRequests).pick({\n  fromUserId: true,\n  toUserId: true,\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = typeof users.$inferSelect;\nexport type Contact = typeof contacts.$inferSelect;\nexport type Message = typeof messages.$inferSelect;\nexport type ContactRequest = typeof contactRequests.$inferSelect;\nexport type InsertContact = z.infer<typeof insertContactSchema>;\nexport type InsertMessage = z.infer<typeof insertMessageSchema>;\nexport type InsertContactRequest = z.infer<typeof insertContactRequestSchema>;\n","path":null,"size_bytes":4808,"size_tokens":null},"client/navigation/MainTabNavigator.tsx":{"content":"import React from \"react\";\nimport { createBottomTabNavigator } from \"@react-navigation/bottom-tabs\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { Platform, StyleSheet, View, Pressable } from \"react-native\";\nimport { BlurView } from \"expo-blur\";\nimport ChatsScreen from \"@/screens/ChatsScreen\";\nimport ContactsScreen from \"@/screens/ContactsScreen\";\nimport ProfileScreen from \"@/screens/ProfileScreen\";\nimport { Colors } from \"@/constants/theme\";\n\nexport type MainTabParamList = {\n  ChatsTab: undefined;\n  ContactsTab: undefined;\n  ProfileTab: undefined;\n};\n\nconst Tab = createBottomTabNavigator<MainTabParamList>();\n\nexport default function MainTabNavigator() {\n  return (\n    <Tab.Navigator\n      initialRouteName=\"ChatsTab\"\n      screenOptions={{\n        tabBarActiveTintColor: Colors.dark.primary,\n        tabBarInactiveTintColor: Colors.dark.tabIconDefault,\n        tabBarStyle: {\n          position: \"absolute\",\n          backgroundColor: Platform.select({\n            ios: \"transparent\",\n            android: Colors.dark.backgroundRoot,\n          }),\n          borderTopWidth: 1,\n          borderTopColor: Colors.dark.border,\n          elevation: 0,\n        },\n        tabBarBackground: () =>\n          Platform.OS === \"ios\" ? (\n            <BlurView\n              intensity={80}\n              tint=\"dark\"\n              style={StyleSheet.absoluteFill}\n            />\n          ) : null,\n        headerShown: false,\n        tabBarLabelStyle: {\n          fontFamily: Platform.OS === \"ios\" ? \"ui-monospace\" : \"monospace\",\n          fontSize: 10,\n          letterSpacing: 0.5,\n        },\n      }}\n    >\n      <Tab.Screen\n        name=\"ChatsTab\"\n        component={ChatsScreen}\n        options={{\n          title: \"CHATS\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"message-square\" size={size} color={color} />\n          ),\n        }}\n      />\n      <Tab.Screen\n        name=\"ContactsTab\"\n        component={ContactsScreen}\n        options={{\n          title: \"CONTACTS\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"users\" size={size} color={color} />\n          ),\n        }}\n      />\n      <Tab.Screen\n        name=\"ProfileTab\"\n        component={ProfileScreen}\n        options={{\n          title: \"PROFILE\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"user\" size={size} color={color} />\n          ),\n        }}\n      />\n    </Tab.Navigator>\n  );\n}\n","path":null,"size_bytes":2446,"size_tokens":null},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","path":null,"size_bytes":325,"size_tokens":null},"design_guidelines.md":{"content":"# Design Guidelines: Encrypted Terminal Messenger\n\n## Architecture Decisions\n\n### Authentication\n**Auth Required** - Military-grade encrypted messaging requires user registration:\n- **Registration Flow:**\n  - Username creation (no email/phone required for privacy)\n  - Automatic cryptographic key generation (Signal Protocol key pairs)\n  - Secure passphrase creation (optional, for key backup/recovery)\n  - Display recovery key (must be saved by user)\n- **No traditional SSO** - Privacy-focused, local key generation\n- **Account Screen includes:**\n  - Username and user ID\n  - QR code for contact pairing\n  - Safety number display for verification\n  - Export/backup encryption keys\n  - Delete account (wipes all local data and keys)\n\n### Navigation\n**Tab Navigation (4 tabs with floating action button):**\n- **Chats** - Main conversation list\n- **Contacts** - Contact management and verification\n- **Scan** - Floating action button (QR scanner overlay)\n- **Profile** - Settings and security options\n\n### Screen Specifications\n\n#### 1. Registration/Onboarding\n- **Purpose:** Create secure identity and generate encryption keys\n- **Layout:**\n  - Transparent header with \"Skip\" button (right) only on username screen\n  - Scrollable form with terminal-style input fields\n  - Submit button below form\n  - Progress indicator showing 3 steps: Username â†’ Keys â†’ Recovery\n- **Components:** Text inputs (terminal style), progress dots, monospace labels, \"Generate Keys\" button with loading animation\n- **Safe Area:** Top: insets.top + Spacing.xl, Bottom: insets.bottom + Spacing.xl\n\n#### 2. Chat List (Main Tab)\n- **Purpose:** View all conversations, access chats\n- **Layout:**\n  - Custom transparent header with \"Terminal Messenger\" title (left), search icon (right)\n  - Scrollable list of chat items\n  - No floating elements\n- **Components:** \n  - Search bar (toggle visibility)\n  - Chat list items showing: contact name, last message preview (encrypted indicator), timestamp, unread badge, online status dot\n  - Empty state: \"No active chats\" with scan QR prompt\n- **Safe Area:** Top: headerHeight + Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n#### 3. Individual Chat Screen\n- **Purpose:** Send/receive encrypted messages\n- **Layout:**\n  - Custom header with contact name, encryption status icon (left: back button, right: menu with verify/settings)\n  - Scrollable message list (inverted)\n  - Fixed message input bar at bottom with encryption toggle\n- **Components:**\n  - Message bubbles (sent/received with different styles)\n  - Self-destruct timer indicator on messages\n  - \"Message deleted\" tombstone for destroyed messages\n  - Terminal-style text input with send button\n  - Encryption status banner (toggleable)\n- **Safe Area:** Top: headerHeight + Spacing.md, Bottom: tabBarHeight + Spacing.md\n\n#### 4. Contacts Tab\n- **Purpose:** Manage contacts, verify identities\n- **Layout:**\n  - Default header with \"Contacts\" title\n  - Scrollable list of contacts\n  - Floating action button (bottom-right) to add contact via QR\n- **Components:**\n  - Contact list items with: avatar placeholder, username, verification status badge, online/offline indicator\n  - Empty state with \"Scan QR to add contact\" CTA\n- **Safe Area:** \n  - Top: headerHeight + Spacing.xl\n  - Bottom: tabBarHeight + Spacing.xl\n  - FAB: bottom: tabBarHeight + Spacing.xl, right: Spacing.xl\n\n#### 5. QR Scanner (Floating Action)\n- **Purpose:** Scan contact QR codes for pairing\n- **Layout:**\n  - Full-screen modal overlay\n  - Camera viewfinder with terminal-style border\n  - Close button (top-left)\n  - \"Or enter code manually\" button below viewfinder\n- **Components:** Camera view, scanning reticle animation, code input modal\n- **Safe Area:** Top: insets.top + Spacing.xl, Bottom: insets.bottom + Spacing.xl\n\n#### 6. Profile/Settings Tab\n- **Purpose:** User profile, security settings, app preferences\n- **Layout:**\n  - Default header with \"Profile\" title\n  - Scrollable form/list\n  - Grouped settings sections\n- **Components:**\n  - User's QR code (for others to scan)\n  - Username display\n  - Settings groups: Security, Privacy, Appearance, Account\n  - Self-destruct default timer settings\n  - Encryption preferences\n  - Log out button (red, at bottom)\n- **Safe Area:** Top: headerHeight + Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n#### 7. Contact Verification Screen\n- **Purpose:** Verify contact's safety number\n- **Layout:**\n  - Default header with \"Verify [Contact]\" title, back button (left)\n  - Scrollable content\n  - \"Mark as Verified\" button at bottom\n- **Components:**\n  - Both safety numbers displayed (yours and contact's)\n  - QR code for in-person verification\n  - Verification instructions\n  - Toggle for verified status\n- **Safe Area:** Top: headerHeight + Spacing.xl, Bottom: insets.bottom + Spacing.xl\n\n## Design System\n\n### Watchdogs Terminal Theme\n\n**Color Palette:**\n- **Background:** Deep black (#0A0E14) with subtle scan-line texture\n- **Surface:** Dark charcoal (#151922)\n- **Primary:** Electric cyan (#00F5FF) - main accent, active elements\n- **Secondary:** Neon green (#39FF14) - success, online status, encryption indicators\n- **Warning:** Amber (#FFB800) - unverified contacts\n- **Danger:** Red (#FF0055) - delete, errors, self-destruct\n- **Text Primary:** Light cyan (#E6F4F1) - main text\n- **Text Secondary:** Dimmed cyan (#7A8C8E) - timestamps, metadata\n- **Text Tertiary:** Dark cyan (#3D4F51) - placeholders\n\n**Typography:**\n- **Font Family:** \"Courier New\" or \"Source Code Pro\" (monospace)\n- **Headers:** 18-24px, bold, letter-spacing: 1.2px, uppercase\n- **Body:** 14-16px, regular\n- **Metadata:** 12px, regular, slightly dimmed\n- **Terminal Prompt:** 14px with \">\" or \"$\" prefix\n\n**Visual Design:**\n- **Terminal Aesthetic:** \n  - Monospace fonts throughout\n  - Subtle CRT scan-line effect on backgrounds\n  - Glowing text effects on primary actions\n  - ASCII art separators between sections\n- **No emojis** - Use terminal symbols (â€¢, >, $, [âœ“], [X])\n- **Icons:** Feather icons from @expo/vector-icons in cyan/green\n- **Borders:** 1px solid cyan with low opacity (#00F5FF22)\n- **Cards/Surfaces:** Dark background with subtle cyan border glow\n- **Floating Elements:** \n  - Floating Action Button (QR scanner): Electric cyan circle with shadowOffset: {width: 0, height: 2}, shadowOpacity: 0.10, shadowRadius: 2\n  - Use subtle drop shadow only for FAB\n\n**Interaction Design:**\n- **Touchable Feedback:**\n  - Buttons: Glow effect on press (increase cyan border brightness)\n  - List items: Darken background + subtle cyan highlight on press\n  - Inputs: Cyan border glow on focus\n- **Animations:**\n  - Typing indicator: Blinking terminal cursor\n  - Message send: Glitch effect transition\n  - Encryption toggle: Fade with lock icon animation\n  - Loading states: Terminal-style spinner or progress bar\n\n**Message Bubbles:**\n- **Sent messages:** Right-aligned, dark surface with cyan left border (3px)\n- **Received messages:** Left-aligned, darker surface with green left border (3px)\n- **Encrypted indicator:** Small lock icon in corner, green when encrypted\n- **Self-destruct timer:** Countdown display in message footer, amber color\n\n**Status Indicators:**\n- **Online:** Bright green dot (#39FF14)\n- **Offline:** Dim gray dot (#3D4F51)\n- **Typing:** Green blinking ellipsis\n- **Encrypted:** Green lock icon\n- **Unencrypted:** Red unlock icon (warning)\n- **Verified contact:** Green checkmark badge\n- **Unverified contact:** Amber warning triangle\n\n**Accessibility:**\n- High contrast ratio (cyan/green on black meets WCAG AAA)\n- Minimum touch target: 44x44 points\n- Screen reader labels for all icons and status indicators\n- Haptic feedback for critical actions (delete, send)\n- Alternative to QR scanning (manual code entry)\n\n### Critical Assets\n1. **Terminal Scan-line Texture:** Subtle overlay for CRT effect\n2. **Glitch Effect Assets:** For transition animations\n3. **Terminal Icons Set:**\n   - Encrypted lock (filled and outline)\n   - QR code scanner reticle\n   - Self-destruct timer icon\n   - Verification badge\n4. **No user avatars** - Use terminal-style initials in monospace (e.g., \"[JD]\", \"[AK]\") on colored backgrounds","path":null,"size_bytes":8127,"size_tokens":null},"server/db.ts":{"content":"import { drizzle } from \"drizzle-orm/node-postgres\";\nimport pg from \"pg\";\nimport * as schema from \"@shared/schema\";\n\nconst { Pool } = pg;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle(pool, { schema });\n","path":null,"size_bytes":395,"size_tokens":null},"client/lib/storage.ts":{"content":"import { Platform } from \"react-native\";\nimport type { KeyPair } from \"@/lib/crypto\";\n\nconst KEYS = {\n  USER: \"@watchdog:user\",\n  IDENTITY_KEY: \"@watchdog:identityKey\",\n  SIGNED_PRE_KEY: \"@watchdog:signedPreKey\",\n  ENCRYPTION_ENABLED: \"@watchdog:encryptionEnabled\",\n  SELF_DESTRUCT_SECONDS: \"@watchdog:selfDestructSeconds\",\n};\n\nconst storage = {\n  getItem: async (key: string): Promise<string | null> => {\n    if (Platform.OS === \"web\") {\n      return localStorage.getItem(key);\n    }\n    const AsyncStorage = (await import(\"@react-native-async-storage/async-storage\")).default;\n    return AsyncStorage.getItem(key);\n  },\n  setItem: async (key: string, value: string): Promise<void> => {\n    if (Platform.OS === \"web\") {\n      localStorage.setItem(key, value);\n      return;\n    }\n    const AsyncStorage = (await import(\"@react-native-async-storage/async-storage\")).default;\n    await AsyncStorage.setItem(key, value);\n  },\n  removeItem: async (key: string): Promise<void> => {\n    if (Platform.OS === \"web\") {\n      localStorage.removeItem(key);\n      return;\n    }\n    const AsyncStorage = (await import(\"@react-native-async-storage/async-storage\")).default;\n    await AsyncStorage.removeItem(key);\n  },\n  multiRemove: async (keys: string[]): Promise<void> => {\n    if (Platform.OS === \"web\") {\n      keys.forEach((key) => localStorage.removeItem(key));\n      return;\n    }\n    const AsyncStorage = (await import(\"@react-native-async-storage/async-storage\")).default;\n    await AsyncStorage.multiRemove(keys);\n  },\n};\n\nexport interface StoredUser {\n  id: string;\n  username: string;\n  publicKey: string;\n  pairingCode: string;\n}\n\nexport async function storeUser(user: StoredUser): Promise<void> {\n  await storage.setItem(KEYS.USER, JSON.stringify(user));\n}\n\nexport async function getStoredUser(): Promise<StoredUser | null> {\n  const data = await storage.getItem(KEYS.USER);\n  return data ? JSON.parse(data) : null;\n}\n\nexport async function storeKeys(\n  identityKey: KeyPair,\n  signedPreKey: KeyPair\n): Promise<void> {\n  await Promise.all([\n    storage.setItem(KEYS.IDENTITY_KEY, JSON.stringify(identityKey)),\n    storage.setItem(KEYS.SIGNED_PRE_KEY, JSON.stringify(signedPreKey)),\n  ]);\n}\n\nexport async function getIdentityKey(): Promise<KeyPair | null> {\n  const data = await storage.getItem(KEYS.IDENTITY_KEY);\n  return data ? JSON.parse(data) : null;\n}\n\nexport async function getSignedPreKey(): Promise<KeyPair | null> {\n  const data = await storage.getItem(KEYS.SIGNED_PRE_KEY);\n  return data ? JSON.parse(data) : null;\n}\n\nexport async function setEncryptionEnabled(enabled: boolean): Promise<void> {\n  await storage.setItem(KEYS.ENCRYPTION_ENABLED, JSON.stringify(enabled));\n}\n\nexport async function getEncryptionEnabled(): Promise<boolean> {\n  const data = await storage.getItem(KEYS.ENCRYPTION_ENABLED);\n  return data ? JSON.parse(data) : true;\n}\n\nexport async function setSelfDestructSeconds(seconds: number | null): Promise<void> {\n  await storage.setItem(KEYS.SELF_DESTRUCT_SECONDS, JSON.stringify(seconds));\n}\n\nexport async function getSelfDestructSeconds(): Promise<number | null> {\n  const data = await storage.getItem(KEYS.SELF_DESTRUCT_SECONDS);\n  return data ? JSON.parse(data) : null;\n}\n\nexport async function clearAllData(): Promise<void> {\n  await storage.multiRemove(Object.values(KEYS));\n}\n","path":null,"size_bytes":3314,"size_tokens":null},"client/screens/ProfileScreen.tsx":{"content":"import React, { useState, useCallback } from \"react\";\nimport {\n  View,\n  ScrollView,\n  StyleSheet,\n  Pressable,\n  Share,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Colors, Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Feather } from \"@expo/vector-icons\";\nimport * as Haptics from \"expo-haptics\";\nimport {\n  getEncryptionEnabled,\n  setEncryptionEnabled,\n  getSelfDestructSeconds,\n  setSelfDestructSeconds,\n} from \"@/lib/storage\";\n\nconst SELF_DESTRUCT_OPTIONS = [\n  { label: \"OFF\", value: null },\n  { label: \"30s\", value: 30 },\n  { label: \"1m\", value: 60 },\n  { label: \"5m\", value: 300 },\n  { label: \"1h\", value: 3600 },\n];\n\nexport default function ProfileScreen() {\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { user, logout } = useAuth();\n  const [encryptionEnabled, setEncryptionEnabledState] = useState(true);\n  const [selfDestruct, setSelfDestructState] = useState<number | null>(null);\n\n  React.useEffect(() => {\n    async function loadSettings() {\n      const [encryption, destruct] = await Promise.all([\n        getEncryptionEnabled(),\n        getSelfDestructSeconds(),\n      ]);\n      setEncryptionEnabledState(encryption);\n      setSelfDestructState(destruct);\n    }\n    loadSettings();\n  }, []);\n\n  const toggleEncryption = useCallback(async () => {\n    const newValue = !encryptionEnabled;\n    setEncryptionEnabledState(newValue);\n    await setEncryptionEnabled(newValue);\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  }, [encryptionEnabled]);\n\n  const handleSelfDestruct = useCallback(async (value: number | null) => {\n    setSelfDestructState(value);\n    await setSelfDestructSeconds(value);\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  }, []);\n\n  const handleShare = useCallback(async () => {\n    if (!user) return;\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    try {\n      await Share.share({\n        message: `Connect with me on Watchdog! My pairing code: ${user.pairingCode}`,\n      });\n    } catch (error) {\n      console.error(\"Share error:\", error);\n    }\n  }, [user]);\n\n  const handleLogout = useCallback(async () => {\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n    await logout();\n  }, [logout]);\n\n  if (!user) return null;\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <ThemedText style={styles.title}>PROFILE</ThemedText>\n      </View>\n\n      <ScrollView\n        contentContainerStyle={[styles.content, { paddingBottom: tabBarHeight + Spacing.xl }]}\n        showsVerticalScrollIndicator={false}\n      >\n        <View style={styles.qrSection}>\n          <View style={styles.qrPlaceholder}>\n            <ThemedText style={styles.qrCode}>{user.pairingCode}</ThemedText>\n          </View>\n          <ThemedText style={styles.username}>{user.username}</ThemedText>\n          <View style={styles.codeContainer}>\n            <ThemedText style={styles.codeLabel}>PAIRING CODE</ThemedText>\n            <ThemedText style={styles.code}>{user.pairingCode}</ThemedText>\n          </View>\n          <Pressable style={({ pressed }) => [styles.shareButton, pressed && styles.shareButtonPressed]} onPress={handleShare}>\n            <Feather name=\"share-2\" size={16} color={Colors.dark.primary} />\n            <ThemedText style={styles.shareButtonText}>SHARE CODE</ThemedText>\n          </Pressable>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText style={styles.sectionTitle}>$ SECURITY</ThemedText>\n          <View style={styles.settingItem}>\n            <View style={styles.settingInfo}>\n              <Feather name=\"lock\" size={18} color={encryptionEnabled ? Colors.dark.secondary : Colors.dark.danger} />\n              <View style={styles.settingText}>\n                <ThemedText style={styles.settingLabel}>End-to-End Encryption</ThemedText>\n                <ThemedText style={styles.settingDescription}>{encryptionEnabled ? \"All messages are encrypted\" : \"Messages sent unencrypted\"}</ThemedText>\n              </View>\n            </View>\n            <Pressable style={[styles.toggle, encryptionEnabled && styles.toggleActive]} onPress={toggleEncryption}>\n              <View style={[styles.toggleKnob, encryptionEnabled && styles.toggleKnobActive]} />\n            </Pressable>\n          </View>\n\n          <View style={styles.settingItem}>\n            <View style={styles.settingInfo}>\n              <Feather name=\"clock\" size={18} color={Colors.dark.warning} />\n              <View style={styles.settingText}>\n                <ThemedText style={styles.settingLabel}>Self-Destruct Timer</ThemedText>\n                <ThemedText style={styles.settingDescription}>Messages auto-delete after being read</ThemedText>\n              </View>\n            </View>\n          </View>\n          <View style={styles.destructOptions}>\n            {SELF_DESTRUCT_OPTIONS.map((option) => (\n              <Pressable key={option.label} style={[styles.destructOption, selfDestruct === option.value && styles.destructOptionActive]} onPress={() => handleSelfDestruct(option.value)}>\n                <ThemedText style={[styles.destructOptionText, selfDestruct === option.value && styles.destructOptionTextActive]}>{option.label}</ThemedText>\n              </Pressable>\n            ))}\n          </View>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText style={styles.sectionTitle}>$ ACCOUNT</ThemedText>\n          <Pressable style={({ pressed }) => [styles.dangerButton, pressed && styles.dangerButtonPressed]} onPress={handleLogout}>\n            <Feather name=\"log-out\" size={18} color={Colors.dark.danger} />\n            <ThemedText style={styles.dangerButtonText}>LOG OUT</ThemedText>\n          </Pressable>\n        </View>\n\n        <View style={styles.footer}>\n          <ThemedText style={styles.footerText}>WATCHDOG v1.0.0</ThemedText>\n          <ThemedText style={styles.footerSubtext}>$ Secure. Private. Encrypted.</ThemedText>\n        </View>\n      </ScrollView>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, backgroundColor: Colors.dark.backgroundRoot },\n  header: { paddingHorizontal: Spacing.lg, paddingBottom: Spacing.md, borderBottomWidth: 1, borderBottomColor: Colors.dark.border },\n  title: { fontSize: 18, fontWeight: \"700\", color: Colors.dark.text, fontFamily: Fonts?.mono, letterSpacing: 2 },\n  content: { paddingHorizontal: Spacing.lg, paddingTop: Spacing.xl },\n  qrSection: { alignItems: \"center\", marginBottom: Spacing[\"2xl\"] },\n  qrPlaceholder: { width: 160, height: 160, backgroundColor: Colors.dark.backgroundDefault, borderRadius: BorderRadius.md, borderWidth: 1, borderColor: Colors.dark.border, marginBottom: Spacing.lg, justifyContent: \"center\", alignItems: \"center\" },\n  qrCode: { fontSize: 24, fontWeight: \"700\", color: Colors.dark.primary, fontFamily: Fonts?.mono, letterSpacing: 2 },\n  username: { fontSize: 20, fontWeight: \"700\", color: Colors.dark.text, fontFamily: Fonts?.mono, letterSpacing: 1, marginBottom: Spacing.sm },\n  codeContainer: { alignItems: \"center\", marginBottom: Spacing.md },\n  codeLabel: { fontSize: 10, color: Colors.dark.textSecondary, fontFamily: Fonts?.mono, letterSpacing: 1, marginBottom: Spacing.xs },\n  code: { fontSize: 18, fontWeight: \"600\", color: Colors.dark.primary, fontFamily: Fonts?.mono, letterSpacing: 2 },\n  shareButton: { flexDirection: \"row\", alignItems: \"center\", gap: Spacing.sm, paddingHorizontal: Spacing.lg, paddingVertical: Spacing.sm, borderRadius: BorderRadius.sm, borderWidth: 1, borderColor: Colors.dark.primary },\n  shareButtonPressed: { backgroundColor: Colors.dark.backgroundDefault },\n  shareButtonText: { fontSize: 12, fontWeight: \"600\", color: Colors.dark.primary, fontFamily: Fonts?.mono, letterSpacing: 0.5 },\n  section: { marginBottom: Spacing[\"2xl\"] },\n  sectionTitle: { fontSize: 12, color: Colors.dark.textSecondary, fontFamily: Fonts?.mono, letterSpacing: 0.5, marginBottom: Spacing.md },\n  settingItem: { flexDirection: \"row\", alignItems: \"center\", justifyContent: \"space-between\", backgroundColor: Colors.dark.backgroundDefault, padding: Spacing.md, borderRadius: BorderRadius.sm, borderWidth: 1, borderColor: Colors.dark.border, marginBottom: Spacing.sm },\n  settingInfo: { flexDirection: \"row\", alignItems: \"center\", flex: 1, gap: Spacing.md },\n  settingText: { flex: 1 },\n  settingLabel: { fontSize: 14, fontWeight: \"600\", color: Colors.dark.text, fontFamily: Fonts?.mono, marginBottom: 2 },\n  settingDescription: { fontSize: 11, color: Colors.dark.textSecondary, fontFamily: Fonts?.mono },\n  toggle: { width: 48, height: 28, borderRadius: 14, backgroundColor: Colors.dark.backgroundSecondary, padding: 2, justifyContent: \"center\" },\n  toggleActive: { backgroundColor: Colors.dark.secondary },\n  toggleKnob: { width: 24, height: 24, borderRadius: 12, backgroundColor: Colors.dark.textSecondary },\n  toggleKnobActive: { backgroundColor: Colors.dark.backgroundRoot, alignSelf: \"flex-end\" },\n  destructOptions: { flexDirection: \"row\", gap: Spacing.sm },\n  destructOption: { flex: 1, paddingVertical: Spacing.sm, backgroundColor: Colors.dark.backgroundDefault, borderRadius: BorderRadius.sm, borderWidth: 1, borderColor: Colors.dark.border, alignItems: \"center\" },\n  destructOptionActive: { backgroundColor: Colors.dark.warning, borderColor: Colors.dark.warning },\n  destructOptionText: { fontSize: 11, fontWeight: \"600\", color: Colors.dark.textSecondary, fontFamily: Fonts?.mono },\n  destructOptionTextActive: { color: Colors.dark.backgroundRoot },\n  dangerButton: { flexDirection: \"row\", alignItems: \"center\", justifyContent: \"center\", gap: Spacing.sm, backgroundColor: Colors.dark.backgroundDefault, padding: Spacing.md, borderRadius: BorderRadius.sm, borderWidth: 1, borderColor: Colors.dark.danger },\n  dangerButtonPressed: { backgroundColor: Colors.dark.backgroundSecondary },\n  dangerButtonText: { fontSize: 14, fontWeight: \"600\", color: Colors.dark.danger, fontFamily: Fonts?.mono, letterSpacing: 0.5 },\n  footer: { alignItems: \"center\", paddingTop: Spacing.xl, paddingBottom: Spacing[\"2xl\"] },\n  footerText: { fontSize: 12, color: Colors.dark.textTertiary, fontFamily: Fonts?.mono, letterSpacing: 1, marginBottom: Spacing.xs },\n  footerSubtext: { fontSize: 10, color: Colors.dark.textTertiary, fontFamily: Fonts?.mono },\n});\n","path":null,"size_bytes":10674,"size_tokens":null},"client/constants/theme.ts":{"content":"import { Platform } from \"react-native\";\n\nexport const Colors = {\n  light: {\n    text: \"#E6F4F1\",\n    textSecondary: \"#7A8C8E\",\n    textTertiary: \"#3D4F51\",\n    buttonText: \"#0A0E14\",\n    tabIconDefault: \"#3D4F51\",\n    tabIconSelected: \"#00F5FF\",\n    link: \"#00F5FF\",\n    backgroundRoot: \"#0A0E14\",\n    backgroundDefault: \"#151922\",\n    backgroundSecondary: \"#1A1F2A\",\n    backgroundTertiary: \"#242B38\",\n    primary: \"#00F5FF\",\n    secondary: \"#39FF14\",\n    warning: \"#FFB800\",\n    danger: \"#FF0055\",\n    border: \"rgba(0, 245, 255, 0.13)\",\n    borderGlow: \"rgba(0, 245, 255, 0.4)\",\n    online: \"#39FF14\",\n    offline: \"#3D4F51\",\n  },\n  dark: {\n    text: \"#E6F4F1\",\n    textSecondary: \"#7A8C8E\",\n    textTertiary: \"#3D4F51\",\n    buttonText: \"#0A0E14\",\n    tabIconDefault: \"#3D4F51\",\n    tabIconSelected: \"#00F5FF\",\n    link: \"#00F5FF\",\n    backgroundRoot: \"#0A0E14\",\n    backgroundDefault: \"#151922\",\n    backgroundSecondary: \"#1A1F2A\",\n    backgroundTertiary: \"#242B38\",\n    primary: \"#00F5FF\",\n    secondary: \"#39FF14\",\n    warning: \"#FFB800\",\n    danger: \"#FF0055\",\n    border: \"rgba(0, 245, 255, 0.13)\",\n    borderGlow: \"rgba(0, 245, 255, 0.4)\",\n    online: \"#39FF14\",\n    offline: \"#3D4F51\",\n  },\n};\n\nexport const Spacing = {\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 20,\n  \"2xl\": 24,\n  \"3xl\": 32,\n  \"4xl\": 40,\n  \"5xl\": 48,\n  inputHeight: 48,\n  buttonHeight: 52,\n};\n\nexport const BorderRadius = {\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 20,\n  \"2xl\": 24,\n  \"3xl\": 32,\n  full: 9999,\n};\n\nexport const Typography = {\n  h1: {\n    fontSize: 24,\n    fontWeight: \"700\" as const,\n    letterSpacing: 1.2,\n  },\n  h2: {\n    fontSize: 20,\n    fontWeight: \"700\" as const,\n    letterSpacing: 1,\n  },\n  h3: {\n    fontSize: 18,\n    fontWeight: \"600\" as const,\n    letterSpacing: 0.8,\n  },\n  h4: {\n    fontSize: 16,\n    fontWeight: \"600\" as const,\n    letterSpacing: 0.5,\n  },\n  body: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n  },\n  small: {\n    fontSize: 12,\n    fontWeight: \"400\" as const,\n  },\n  link: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n  },\n  terminal: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n    letterSpacing: 0.5,\n  },\n};\n\nexport const Fonts = Platform.select({\n  ios: {\n    sans: \"system-ui\",\n    serif: \"ui-serif\",\n    rounded: \"ui-rounded\",\n    mono: \"ui-monospace\",\n  },\n  default: {\n    sans: \"normal\",\n    serif: \"serif\",\n    rounded: \"normal\",\n    mono: \"monospace\",\n  },\n  web: {\n    sans: \"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\",\n    serif: \"Georgia, 'Times New Roman', serif\",\n    rounded: \"'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif\",\n    mono: \"'Courier New', SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace\",\n  },\n});\n","path":null,"size_bytes":2786,"size_tokens":null},"client/hooks/useScreenOptions.ts":{"content":"import { Platform } from \"react-native\";\nimport { NativeStackNavigationOptions } from \"@react-navigation/native-stack\";\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\ninterface UseScreenOptionsParams {\n  transparent?: boolean;\n}\n\nexport function useScreenOptions({\n  transparent = true,\n}: UseScreenOptionsParams = {}): NativeStackNavigationOptions {\n  const { theme, isDark } = useTheme();\n\n  return {\n    headerTitleAlign: \"center\",\n    headerTransparent: transparent,\n    headerBlurEffect: isDark ? \"dark\" : \"light\",\n    headerTintColor: theme.text,\n    headerStyle: {\n      backgroundColor: Platform.select({\n        ios: undefined,\n        android: theme.backgroundRoot,\n        web: theme.backgroundRoot,\n      }),\n    },\n    gestureEnabled: true,\n    gestureDirection: \"horizontal\",\n    fullScreenGestureEnabled: isLiquidGlassAvailable() ? false : true,\n    contentStyle: {\n      backgroundColor: theme.backgroundRoot,\n    },\n  };\n}\n","path":null,"size_bytes":1000,"size_tokens":null},"client/components/Button.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { BorderRadius, Spacing } from \"@/constants/theme\";\n\ninterface ButtonProps {\n  onPress?: () => void;\n  children: ReactNode;\n  style?: StyleProp<ViewStyle>;\n  disabled?: boolean;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Button({\n  onPress,\n  children,\n  style,\n  disabled = false,\n}: ButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (!disabled) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={disabled}\n      style={[\n        styles.button,\n        {\n          backgroundColor: theme.link,\n          opacity: disabled ? 0.5 : 1,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"body\"\n        style={[styles.buttonText, { color: theme.buttonText }]}\n      >\n        {children}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  buttonText: {\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":2014,"size_tokens":null},"client/screens/RegisterScreen.tsx":{"content":"import React, { useState } from \"react\";\nimport {\n  View,\n  TextInput,\n  StyleSheet,\n  Platform,\n  ActivityIndicator,\n  Pressable,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { KeyboardAwareScrollViewCompat } from \"@/components/KeyboardAwareScrollViewCompat\";\nimport { Colors, Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Feather } from \"@expo/vector-icons\";\nimport * as Haptics from \"expo-haptics\";\n\nexport default function RegisterScreen() {\n  const insets = useSafeAreaInsets();\n  const { register } = useAuth();\n  const [username, setUsername] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [step, setStep] = useState<\"username\" | \"generating\" | \"complete\">(\"username\");\n\n  const handleRegister = async () => {\n    if (!username.trim()) {\n      setError(\"Username is required\");\n      return;\n    }\n\n    if (username.length < 3) {\n      setError(\"Username must be at least 3 characters\");\n      return;\n    }\n\n    setError(null);\n    setIsLoading(true);\n    setStep(\"generating\");\n\n    try {\n      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n      await register(username.trim());\n      setStep(\"complete\");\n    } catch (err: any) {\n      setError(err.message || \"Registration failed\");\n      setStep(\"username\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <KeyboardAwareScrollViewCompat\n        contentContainerStyle={[\n          styles.content,\n          {\n            paddingTop: insets.top + Spacing[\"3xl\"],\n            paddingBottom: insets.bottom + Spacing.xl,\n          },\n        ]}\n      >\n        <View style={styles.header}>\n          <View style={styles.iconContainer}>\n            <Feather name=\"shield\" size={48} color={Colors.dark.primary} />\n          </View>\n          <ThemedText style={styles.title}>WATCHDOG</ThemedText>\n          <ThemedText style={styles.subtitle}>\n            $ SECURE TERMINAL MESSENGER\n          </ThemedText>\n        </View>\n\n        {step === \"username\" && (\n          <View style={styles.form}>\n            <ThemedText style={styles.label}>&gt; ENTER USERNAME</ThemedText>\n            <View style={styles.inputContainer}>\n              <ThemedText style={styles.prompt}>$</ThemedText>\n              <TextInput\n                style={styles.input}\n                value={username}\n                onChangeText={setUsername}\n                placeholder=\"username\"\n                placeholderTextColor={Colors.dark.textTertiary}\n                autoCapitalize=\"none\"\n                autoCorrect={false}\n                maxLength={20}\n              />\n              <View style={styles.cursor} />\n            </View>\n\n            {error ? (\n              <ThemedText style={styles.error}>[ERROR] {error}</ThemedText>\n            ) : null}\n\n            <Pressable\n              style={({ pressed }) => [\n                styles.button,\n                pressed && styles.buttonPressed,\n                !username.trim() && styles.buttonDisabled,\n              ]}\n              onPress={handleRegister}\n              disabled={!username.trim() || isLoading}\n            >\n              <ThemedText style={styles.buttonText}>\n                GENERATE KEYS\n              </ThemedText>\n              <Feather name=\"arrow-right\" size={18} color={Colors.dark.buttonText} />\n            </Pressable>\n\n            <View style={styles.infoBox}>\n              <Feather name=\"lock\" size={14} color={Colors.dark.secondary} />\n              <ThemedText style={styles.infoText}>\n                End-to-end encryption keys will be generated locally on your device.\n                Your private keys never leave this device.\n              </ThemedText>\n            </View>\n          </View>\n        )}\n\n        {step === \"generating\" && (\n          <View style={styles.generatingContainer}>\n            <ActivityIndicator size=\"large\" color={Colors.dark.primary} />\n            <ThemedText style={styles.generatingText}>\n              $ GENERATING ENCRYPTION KEYS...\n            </ThemedText>\n            <View style={styles.progressContainer}>\n              <View style={styles.progressBar}>\n                <View style={styles.progressFill} />\n              </View>\n            </View>\n            <ThemedText style={styles.generatingSubtext}>\n              Creating identity keys{\"\\n\"}\n              Generating signed pre-key{\"\\n\"}\n              Securing local storage\n            </ThemedText>\n          </View>\n        )}\n      </KeyboardAwareScrollViewCompat>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  content: {\n    flexGrow: 1,\n    paddingHorizontal: Spacing.xl,\n  },\n  header: {\n    alignItems: \"center\",\n    marginBottom: Spacing[\"4xl\"],\n  },\n  iconContainer: {\n    width: 80,\n    height: 80,\n    borderRadius: BorderRadius.lg,\n    backgroundColor: Colors.dark.backgroundDefault,\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  title: {\n    fontSize: 28,\n    fontWeight: \"700\",\n    color: Colors.dark.primary,\n    letterSpacing: 4,\n    fontFamily: Fonts?.mono,\n    marginBottom: Spacing.xs,\n  },\n  subtitle: {\n    fontSize: 12,\n    color: Colors.dark.textSecondary,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 1,\n  },\n  form: {\n    flex: 1,\n  },\n  label: {\n    fontSize: 14,\n    color: Colors.dark.secondary,\n    fontFamily: Fonts?.mono,\n    marginBottom: Spacing.md,\n    letterSpacing: 0.5,\n  },\n  inputContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    backgroundColor: Colors.dark.backgroundDefault,\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n    borderRadius: BorderRadius.sm,\n    paddingHorizontal: Spacing.md,\n    height: Spacing.inputHeight,\n    marginBottom: Spacing.lg,\n  },\n  prompt: {\n    fontSize: 16,\n    color: Colors.dark.secondary,\n    fontFamily: Fonts?.mono,\n    marginRight: Spacing.sm,\n  },\n  input: {\n    flex: 1,\n    fontSize: 16,\n    color: Colors.dark.text,\n    fontFamily: Fonts?.mono,\n    padding: 0,\n  },\n  cursor: {\n    width: 8,\n    height: 18,\n    backgroundColor: Colors.dark.primary,\n    opacity: 0.7,\n  },\n  error: {\n    fontSize: 12,\n    color: Colors.dark.danger,\n    fontFamily: Fonts?.mono,\n    marginBottom: Spacing.lg,\n  },\n  button: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    backgroundColor: Colors.dark.primary,\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  buttonPressed: {\n    opacity: 0.8,\n    backgroundColor: Colors.dark.borderGlow,\n  },\n  buttonDisabled: {\n    opacity: 0.5,\n  },\n  buttonText: {\n    fontSize: 14,\n    fontWeight: \"600\",\n    color: Colors.dark.buttonText,\n    fontFamily: Fonts?.mono,\n    letterSpacing: 1,\n  },\n  infoBox: {\n    flexDirection: \"row\",\n    alignItems: \"flex-start\",\n    backgroundColor: Colors.dark.backgroundDefault,\n    borderWidth: 1,\n    borderColor: Colors.dark.border,\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.md,\n    marginTop: Spacing[\"2xl\"],\n    gap: Spacing.sm,\n  },\n  infoText: {\n    flex: 1,\n    fontSize: 12,\n    color: Colors.dark.textSecondary,\n    fontFamily: Fonts?.mono,\n    lineHeight: 18,\n  },\n  generatingContainer: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  generatingText: {\n    fontSize: 14,\n    color: Colors.dark.primary,\n    fontFamily: Fonts?.mono,\n    marginTop: Spacing.xl,\n    letterSpacing: 0.5,\n  },\n  progressContainer: {\n    width: \"100%\",\n    marginTop: Spacing.xl,\n    marginBottom: Spacing.xl,\n  },\n  progressBar: {\n    height: 4,\n    backgroundColor: Colors.dark.backgroundDefault,\n    borderRadius: 2,\n    overflow: \"hidden\",\n  },\n  progressFill: {\n    height: \"100%\",\n    width: \"60%\",\n    backgroundColor: Colors.dark.secondary,\n  },\n  generatingSubtext: {\n    fontSize: 12,\n    color: Colors.dark.textSecondary,\n    fontFamily: Fonts?.mono,\n    textAlign: \"center\",\n    lineHeight: 20,\n  },\n});\n","path":null,"size_bytes":8350,"size_tokens":null},"scripts/build.js":{"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { spawn } = require(\"child_process\");\nconst { Readable } = require(\"stream\");\nconst { pipeline } = require(\"stream/promises\");\n\nlet metroProcess = null;\n\nfunction exitWithError(message) {\n  console.error(message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n}\n\nfunction setupSignalHandlers() {\n  const cleanup = () => {\n    if (metroProcess) {\n      console.log(\"Cleaning up Metro process...\");\n      metroProcess.kill();\n    }\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", cleanup);\n  process.on(\"SIGTERM\", cleanup);\n  process.on(\"SIGHUP\", cleanup);\n}\n\nfunction stripProtocol(domain) {\n  let urlString = domain.trim();\n\n  if (!/^https?:\\/\\//i.test(urlString)) {\n    urlString = `https://${urlString}`;\n  }\n\n  return new URL(urlString).host;\n}\n\nfunction getDeploymentDomain() {\n  // Check Replit deployment environment variables first\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    return stripProtocol(process.env.REPLIT_INTERNAL_APP_DOMAIN);\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    return stripProtocol(process.env.REPLIT_DEV_DOMAIN);\n  }\n\n  if (process.env.EXPO_PUBLIC_DOMAIN) {\n    return stripProtocol(process.env.EXPO_PUBLIC_DOMAIN);\n  }\n\n  console.error(\n    \"ERROR: No deployment domain found. Set REPLIT_INTERNAL_APP_DOMAIN, REPLIT_DEV_DOMAIN, or EXPO_PUBLIC_DOMAIN\",\n  );\n  process.exit(1);\n}\n\nfunction prepareDirectories(timestamp) {\n  console.log(\"Preparing build directories...\");\n\n  if (fs.existsSync(\"static-build\")) {\n    fs.rmSync(\"static-build\", { recursive: true });\n  }\n\n  const dirs = [\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"ios\"),\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"android\"),\n    path.join(\"static-build\", \"ios\"),\n    path.join(\"static-build\", \"android\"),\n  ];\n\n  for (const dir of dirs) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  console.log(\"Build:\", timestamp);\n}\n\nfunction clearMetroCache() {\n  console.log(\"Clearing Metro cache...\");\n\n  const cacheDirs = [\n    ...fs.globSync(\".metro-cache\"),\n    ...fs.globSync(\"node_modules/.cache/metro\"),\n  ];\n\n  for (const dir of cacheDirs) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  }\n\n  console.log(\"Cache cleared\");\n}\n\nasync function checkMetroHealth() {\n  try {\n    const response = await fetch(\"http://localhost:8081/status\", {\n      signal: AbortSignal.timeout(5000),\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function startMetro(expoPublicDomain) {\n  const isRunning = await checkMetroHealth();\n  if (isRunning) {\n    console.log(\"Metro already running\");\n    return;\n  }\n\n  console.log(\"Starting Metro...\");\n  console.log(`Setting EXPO_PUBLIC_DOMAIN=${expoPublicDomain}`);\n  const env = {\n    ...process.env,\n    EXPO_PUBLIC_DOMAIN: expoPublicDomain,\n  };\n  metroProcess = spawn(\"npm\", [\"run\", \"expo:start:static:build\"], {\n    stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    detached: false,\n    env,\n  });\n\n  if (metroProcess.stdout) {\n    metroProcess.stdout.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.log(`[Metro] ${output}`);\n    });\n  }\n  if (metroProcess.stderr) {\n    metroProcess.stderr.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.error(`[Metro Error] ${output}`);\n    });\n  }\n\n  for (let i = 0; i < 60; i++) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    const healthy = await checkMetroHealth();\n    if (healthy) {\n      console.log(\"Metro ready\");\n      return;\n    }\n  }\n\n  console.error(\"Metro timeout\");\n  process.exit(1);\n}\n\nasync function downloadFile(url, outputPath) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 120_000);\n\n  try {\n    console.log(`Downloading: ${url}`);\n    const response = await fetch(url, { signal: controller.signal });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const file = fs.createWriteStream(outputPath);\n    await pipeline(Readable.fromWeb(response.body), file);\n\n    const fileSize = fs.statSync(outputPath).size;\n\n    if (fileSize === 0) {\n      fs.unlinkSync(outputPath);\n      throw new Error(\"Downloaded file is empty\");\n    }\n  } catch (error) {\n    if (fs.existsSync(outputPath)) {\n      fs.unlinkSync(outputPath);\n    }\n\n    if (error.name === \"AbortError\") {\n      throw new Error(`Download timeout after 2m: ${url}`);\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundle(platform, timestamp) {\n  const url = new URL(\"http://localhost:8081/client/index.bundle\");\n  url.searchParams.set(\"platform\", platform);\n  url.searchParams.set(\"dev\", \"false\");\n  url.searchParams.set(\"hot\", \"false\");\n  url.searchParams.set(\"lazy\", \"false\");\n  url.searchParams.set(\"minify\", \"true\");\n\n  const output = path.join(\n    \"static-build\",\n    timestamp,\n    \"_expo\",\n    \"static\",\n    \"js\",\n    platform,\n    \"bundle.js\",\n  );\n\n  console.log(`Fetching ${platform} bundle...`);\n  await downloadFile(url.toString(), output);\n  console.log(`${platform} bundle ready`);\n}\n\nasync function downloadManifest(platform) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 300_000);\n\n  try {\n    console.log(`Fetching ${platform} manifest...`);\n    const response = await fetch(\"http://localhost:8081/manifest\", {\n      headers: { \"expo-platform\": platform },\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const manifest = await response.json();\n    console.log(`${platform} manifest ready`);\n    return manifest;\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      throw new Error(\n        `Manifest download timeout after 5m for platform: ${platform}`,\n      );\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundlesAndManifests(timestamp) {\n  console.log(\"Downloading bundles and manifests...\");\n  console.log(\"This may take several minutes for production builds...\");\n\n  try {\n    const results = await Promise.allSettled([\n      downloadBundle(\"ios\", timestamp),\n      downloadBundle(\"android\", timestamp),\n      downloadManifest(\"ios\"),\n      downloadManifest(\"android\"),\n    ]);\n\n    const failures = results\n      .map((result, index) => ({ result, index }))\n      .filter(({ result }) => result.status === \"rejected\");\n\n    if (failures.length > 0) {\n      const errorMessages = failures.map(({ result, index }) => {\n        const names = [\n          \"iOS bundle\",\n          \"Android bundle\",\n          \"iOS manifest\",\n          \"Android manifest\",\n        ];\n        return `  - ${names[index]}: ${result.reason?.message || result.reason}`;\n      });\n\n      exitWithError(`Download failed:\\n${errorMessages.join(\"\\n\")}`);\n    }\n\n    const iosManifest =\n      results[2].status === \"fulfilled\" ? results[2].value : null;\n    const androidManifest =\n      results[3].status === \"fulfilled\" ? results[3].value : null;\n\n    console.log(\"All downloads completed successfully\");\n    return { ios: iosManifest, android: androidManifest };\n  } catch (error) {\n    exitWithError(`Unexpected download error: ${error.message}`);\n  }\n}\n\nfunction extractAssets(timestamp) {\n  const bundles = {\n    ios: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"ios\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n    android: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"android\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n  };\n\n  const assetsMap = new Map();\n  const assetPattern =\n    /httpServerLocation:\"([^\"]+)\"[^}]*hash:\"([^\"]+)\"[^}]*name:\"([^\"]+)\"[^}]*type:\"([^\"]+)\"/g;\n\n  const extractFromBundle = (bundle, platform) => {\n    for (const match of bundle.matchAll(assetPattern)) {\n      const originalPath = match[1];\n      const filename = match[3] + \".\" + match[4];\n\n      const tempUrl = new URL(`http://localhost:8081${originalPath}`);\n      const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n      if (!unstablePath) {\n        throw new Error(`Asset missing unstable_path: ${originalPath}`);\n      }\n\n      const decodedPath = decodeURIComponent(unstablePath);\n      const key = path.posix.join(decodedPath, filename);\n\n      if (!assetsMap.has(key)) {\n        const asset = {\n          url: path.posix.join(\"/\", decodedPath, filename),\n          originalPath: originalPath,\n          filename: filename,\n          relativePath: decodedPath,\n          hash: match[2],\n          platforms: new Set(),\n        };\n\n        assetsMap.set(key, asset);\n      }\n      assetsMap.get(key).platforms.add(platform);\n    }\n  };\n\n  extractFromBundle(bundles.ios, \"ios\");\n  extractFromBundle(bundles.android, \"android\");\n\n  return Array.from(assetsMap.values());\n}\n\nasync function downloadAssets(assets, timestamp) {\n  if (assets.length === 0) {\n    return 0;\n  }\n\n  console.log(\"Downloading assets...\");\n  let successCount = 0;\n  const failures = [];\n\n  const downloadPromises = assets.map(async (asset) => {\n    const platform = Array.from(asset.platforms)[0];\n\n    const tempUrl = new URL(`http://localhost:8081${asset.originalPath}`);\n    const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n    if (!unstablePath) {\n      throw new Error(`Asset missing unstable_path: ${asset.originalPath}`);\n    }\n\n    const decodedPath = decodeURIComponent(unstablePath);\n    const metroUrl = new URL(\n      `http://localhost:8081${path.posix.join(\"/assets\", decodedPath, asset.filename)}`,\n    );\n    metroUrl.searchParams.set(\"platform\", platform);\n    metroUrl.searchParams.set(\"hash\", asset.hash);\n\n    const outputDir = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      asset.relativePath,\n    );\n    fs.mkdirSync(outputDir, { recursive: true });\n    const output = path.join(outputDir, asset.filename);\n\n    try {\n      await downloadFile(metroUrl.toString(), output);\n      successCount++;\n    } catch (error) {\n      failures.push({\n        filename: asset.filename,\n        error: error.message,\n        url: metroUrl.toString(),\n      });\n    }\n  });\n\n  await Promise.all(downloadPromises);\n\n  if (failures.length > 0) {\n    const errorMsg =\n      `Failed to download ${failures.length} asset(s):\\n` +\n      failures\n        .map((f) => `  - ${f.filename}: ${f.error} (${f.url})`)\n        .join(\"\\n\");\n    exitWithError(errorMsg);\n  }\n\n  console.log(`Downloaded ${successCount} assets`);\n  return successCount;\n}\n\nfunction updateBundleUrls(timestamp, baseUrl) {\n  const updateForPlatform = (platform) => {\n    const bundlePath = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      platform,\n      \"bundle.js\",\n    );\n    let bundle = fs.readFileSync(bundlePath, \"utf-8\");\n\n    bundle = bundle.replace(\n      /httpServerLocation:\"(\\/[^\"]+)\"/g,\n      (_match, capturedPath) => {\n        const tempUrl = new URL(`http://localhost:8081${capturedPath}`);\n        const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n        if (!unstablePath) {\n          throw new Error(\n            `Asset missing unstable_path in bundle: ${capturedPath}`,\n          );\n        }\n\n        const decodedPath = decodeURIComponent(unstablePath);\n        return `httpServerLocation:\"${baseUrl}/${timestamp}/_expo/static/js/${decodedPath}\"`;\n      },\n    );\n\n    fs.writeFileSync(bundlePath, bundle);\n  };\n\n  updateForPlatform(\"ios\");\n  updateForPlatform(\"android\");\n  console.log(\"Updated bundle URLs\");\n}\n\nfunction updateManifests(manifests, timestamp, baseUrl, assetsByHash) {\n  const updateForPlatform = (platform, manifest) => {\n    if (!manifest.launchAsset || !manifest.extra) {\n      exitWithError(`Malformed manifest for ${platform}`);\n    }\n\n    manifest.launchAsset.url = `${baseUrl}/${timestamp}/_expo/static/js/${platform}/bundle.js`;\n    manifest.launchAsset.key = `bundle-${timestamp}`;\n    manifest.createdAt = new Date(\n      Number(timestamp.split(\"-\")[0]),\n    ).toISOString();\n    manifest.extra.expoClient.hostUri =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.debuggerHost =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.packagerOpts.dev = false;\n\n    if (manifest.assets && manifest.assets.length > 0) {\n      manifest.assets.forEach((asset) => {\n        if (!asset.url) return;\n\n        const hash = asset.hash;\n        if (!hash) return;\n\n        const assetInfo = assetsByHash.get(hash);\n        if (!assetInfo) return;\n\n        asset.url = `${baseUrl}/${timestamp}/_expo/static/js/${assetInfo.relativePath}/${assetInfo.filename}`;\n      });\n    }\n\n    fs.writeFileSync(\n      path.join(\"static-build\", platform, \"manifest.json\"),\n      JSON.stringify(manifest, null, 2),\n    );\n  };\n\n  updateForPlatform(\"ios\", manifests.ios);\n  updateForPlatform(\"android\", manifests.android);\n  console.log(\"Manifests updated\");\n}\n\nasync function main() {\n  console.log(\"Building static Expo Go deployment...\");\n\n  setupSignalHandlers();\n\n  const domain = getDeploymentDomain();\n  const baseUrl = `https://${domain}`;\n  const timestamp = `${Date.now()}-${process.pid}`;\n\n  prepareDirectories(timestamp);\n  clearMetroCache();\n\n  await startMetro(domain);\n\n  const downloadTimeout = 300000;\n  const downloadPromise = downloadBundlesAndManifests(timestamp);\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(\n        new Error(\n          `Overall download timeout after ${downloadTimeout / 1000} seconds. ` +\n            \"Metro may be struggling to generate bundles. Check Metro logs above.\",\n        ),\n      );\n    }, downloadTimeout);\n  });\n\n  const manifests = await Promise.race([downloadPromise, timeoutPromise]);\n\n  console.log(\"Processing assets...\");\n  const assets = extractAssets(timestamp);\n  console.log(\"Found\", assets.length, \"unique asset(s)\");\n\n  const assetsByHash = new Map();\n  for (const asset of assets) {\n    assetsByHash.set(asset.hash, {\n      relativePath: asset.relativePath,\n      filename: asset.filename,\n    });\n  }\n\n  const assetCount = await downloadAssets(assets, timestamp);\n\n  if (assetCount > 0) {\n    updateBundleUrls(timestamp, baseUrl);\n  }\n\n  console.log(\"Updating manifests and creating landing page...\");\n  updateManifests(manifests, timestamp, baseUrl, assetsByHash);\n\n  console.log(\"Build complete! Deploy to:\", baseUrl);\n\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.error(\"Build failed:\", error.message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n});\n","path":null,"size_bytes":14884,"size_tokens":null},"client/screens/ChatScreen.tsx":{"content":"import React, { useState, useEffect, useCallback, useRef } from \"react\";\nimport { View, FlatList, TextInput, StyleSheet, Pressable, KeyboardAvoidingView, Platform } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useRoute, useNavigation } from \"@react-navigation/native\";\nimport type { RouteProp } from \"@react-navigation/native\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Colors, Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\nimport { useAuth } from \"@/context/AuthContext\";\nimport { Feather } from \"@expo/vector-icons\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { getSocket, emitSendMessage, emitMessageRead, emitTyping } from \"@/lib/socket\";\nimport { encryptMessage, decryptMessage } from \"@/lib/crypto\";\nimport { getEncryptionEnabled, getSelfDestructSeconds } from \"@/lib/storage\";\nimport * as Haptics from \"expo-haptics\";\n\ntype ChatRouteProp = RouteProp<RootStackParamList, \"Chat\">;\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\ninterface Message {\n  id: string;\n  senderId: string;\n  recipientId: string;\n  encryptedContent: string;\n  nonce: string;\n  isEncrypted: boolean;\n  isRead: boolean;\n  createdAt: string;\n  selfDestructSeconds?: number;\n}\n\nexport default function ChatScreen() {\n  const insets = useSafeAreaInsets();\n  const route = useRoute<ChatRouteProp>();\n  const navigation = useNavigation<NavigationProp>();\n  const { contactId, contactName, contactPublicKey } = route.params;\n  const { user, identityKey } = useAuth();\n  const queryClient = useQueryClient();\n  \n  const [message, setMessage] = useState(\"\");\n  const [encryptionEnabled, setEncryptionEnabled] = useState(true);\n  const [selfDestructSeconds, setSelfDestructSeconds] = useState<number | null>(null);\n  const [isTyping, setIsTyping] = useState(false);\n  const flatListRef = useRef<FlatList>(null);\n\n  const { data: messages, refetch } = useQuery<Message[]>({\n    queryKey: [\"/api/messages\", user?.id, contactId],\n    enabled: !!user?.id,\n  });\n\n  useEffect(() => {\n    navigation.setOptions({\n      headerTitle: () => (\n        <View style={styles.headerTitle}>\n          <ThemedText style={styles.headerName}>{contactName}</ThemedText>\n          <View style={styles.encryptedBadge}>\n            <Feather name=\"lock\" size={10} color={Colors.dark.secondary} />\n            <ThemedText style={styles.encryptedText}>ENCRYPTED</ThemedText>\n          </View>\n        </View>\n      ),\n    });\n  }, [navigation, contactName]);\n\n  useEffect(() => {\n    async function loadSettings() {\n      const [encryption, destruct] = await Promise.all([\n        getEncryptionEnabled(),\n        getSelfDestructSeconds(),\n      ]);\n      setEncryptionEnabled(encryption);\n      setSelfDestructSeconds(destruct);\n    }\n    loadSettings();\n  }, []);\n\n  useEffect(() => {\n    const socket = getSocket();\n\n    const handleNewMessage = (msg: Message) => {\n      if (msg.senderId === contactId || msg.recipientId === contactId) {\n        queryClient.invalidateQueries({ queryKey: [\"/api/messages\", user?.id, contactId] });\n        if (msg.senderId === contactId) {\n          emitMessageRead(msg.id);\n        }\n      }\n    };\n\n    const handleTyping = ({ senderId }: { senderId: string }) => {\n      if (senderId === contactId) {\n        setIsTyping(true);\n        setTimeout(() => setIsTyping(false), 3000);\n      }\n    };\n\n    socket.on(\"message:receive\", handleNewMessage);\n    socket.on(\"message:sent\", handleNewMessage);\n    socket.on(\"message:typing\", handleTyping);\n\n    return () => {\n      socket.off(\"message:receive\", handleNewMessage);\n      socket.off(\"message:sent\", handleNewMessage);\n      socket.off(\"message:typing\", handleTyping);\n    };\n  }, [contactId, user?.id, queryClient]);\n\n  const handleSend = useCallback(async () => {\n    if (!message.trim() || !user || !identityKey) return;\n\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n\n    let encryptedContent = message;\n    let nonce = \"\";\n\n    if (encryptionEnabled) {\n      const encrypted = encryptMessage(message, contactPublicKey, identityKey.secretKey);\n      encryptedContent = encrypted.encryptedContent;\n      nonce = encrypted.nonce;\n    }\n\n    emitSendMessage({\n      senderId: user.id,\n      recipientId: contactId,\n      encryptedContent,\n      nonce,\n      isEncrypted: encryptionEnabled,\n      selfDestructSeconds: selfDestructSeconds || undefined,\n    });\n\n    setMessage(\"\");\n  }, [message, user, identityKey, encryptionEnabled, contactPublicKey, contactId, selfDestructSeconds]);\n\n  const handleTypingIndicator = useCallback(() => {\n    if (user) {\n      emitTyping(user.id, contactId);\n    }\n  }, [user, contactId]);\n\n  const decryptMessageContent = useCallback((msg: Message): string => {\n    if (!msg.isEncrypted || !identityKey) {\n      return msg.encryptedContent;\n    }\n    const decrypted = decryptMessage(msg.encryptedContent, msg.nonce, contactPublicKey, identityKey.secretKey);\n    return decrypted || \"[Unable to decrypt]\";\n  }, [identityKey, contactPublicKey]);\n\n  const renderMessage = useCallback(({ item }: { item: Message }) => {\n    const isSent = item.senderId === user?.id;\n    const content = decryptMessageContent(item);\n    const time = new Date(item.createdAt).toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" });\n\n    return (\n      <View style={[styles.messageContainer, isSent ? styles.messageSent : styles.messageReceived]}>\n        <View style={[styles.messageBubble, isSent ? styles.bubbleSent : styles.bubbleReceived]}>\n          <ThemedText style={styles.messageText}>{content}</ThemedText>\n          <View style={styles.messageFooter}>\n            {item.isEncrypted ? (\n              <Feather name=\"lock\" size={10} color={Colors.dark.secondary} />\n            ) : (\n              <Feather name=\"unlock\" size={10} color={Colors.dark.danger} />\n            )}\n            <ThemedText style={styles.messageTime}>{time}</ThemedText>\n            {isSent && (\n              <Feather name={item.isRead ? \"check-circle\" : \"check\"} size={10} color={item.isRead ? Colors.dark.secondary : Colors.dark.textTertiary} />\n            )}\n          </View>\n        </View>\n      </View>\n    );\n  }, [user?.id, decryptMessageContent]);\n\n  return (\n    <ThemedView style={styles.container}>\n      <KeyboardAvoidingView style={styles.keyboardView} behavior={Platform.OS === \"ios\" ? \"padding\" : undefined} keyboardVerticalOffset={90}>\n        <FlatList\n          ref={flatListRef}\n          data={messages || []}\n          keyExtractor={(item) => item.id}\n          renderItem={renderMessage}\n          inverted\n          contentContainerStyle={styles.messagesList}\n          ListHeaderComponent={isTyping ? (\n            <View style={styles.typingContainer}>\n              <ThemedText style={styles.typingText}>$ {contactName} is typing...</ThemedText>\n            </View>\n          ) : null}\n        />\n\n        <View style={[styles.inputContainer, { paddingBottom: insets.bottom + Spacing.sm }]}>\n          <View style={styles.inputRow}>\n            <Pressable style={[styles.encryptToggle, !encryptionEnabled && styles.encryptToggleOff]} onPress={() => setEncryptionEnabled(!encryptionEnabled)}>\n              <Feather name={encryptionEnabled ? \"lock\" : \"unlock\"} size={18} color={encryptionEnabled ? Colors.dark.secondary : Colors.dark.danger} />\n            </Pressable>\n            <View style={styles.textInputWrapper}>\n              <ThemedText style={styles.prompt}>$</ThemedText>\n              <TextInput\n                style={styles.textInput}\n                value={message}\n                onChangeText={(text) => { setMessage(text); handleTypingIndicator(); }}\n                placeholder=\"Enter message...\"\n                placeholderTextColor={Colors.dark.textTertiary}\n                multiline\n                maxLength={1000}\n              />\n            </View>\n            <Pressable style={({ pressed }) => [styles.sendButton, pressed && styles.sendButtonPressed, !message.trim() && styles.sendButtonDisabled]} onPress={handleSend} disabled={!message.trim()}>\n              <Feather name=\"send\" size={18} color={message.trim() ? Colors.dark.buttonText : Colors.dark.textTertiary} />\n            </Pressable>\n          </View>\n        </View>\n      </KeyboardAvoidingView>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, backgroundColor: Colors.dark.backgroundRoot },\n  keyboardView: { flex: 1 },\n  headerTitle: { alignItems: \"center\" },\n  headerName: { fontSize: 16, fontWeight: \"600\", color: Colors.dark.text, fontFamily: Fonts?.mono },\n  encryptedBadge: { flexDirection: \"row\", alignItems: \"center\", gap: 4 },\n  encryptedText: { fontSize: 9, color: Colors.dark.secondary, fontFamily: Fonts?.mono, letterSpacing: 0.5 },\n  messagesList: { paddingHorizontal: Spacing.md, paddingVertical: Spacing.sm },\n  messageContainer: { marginVertical: Spacing.xs },\n  messageSent: { alignItems: \"flex-end\" },\n  messageReceived: { alignItems: \"flex-start\" },\n  messageBubble: { maxWidth: \"80%\", padding: Spacing.md, borderRadius: BorderRadius.sm },\n  bubbleSent: { backgroundColor: Colors.dark.backgroundSecondary, borderLeftWidth: 3, borderLeftColor: Colors.dark.primary },\n  bubbleReceived: { backgroundColor: Colors.dark.backgroundDefault, borderLeftWidth: 3, borderLeftColor: Colors.dark.secondary },\n  messageText: { fontSize: 14, color: Colors.dark.text, fontFamily: Fonts?.mono },\n  messageFooter: { flexDirection: \"row\", alignItems: \"center\", gap: Spacing.xs, marginTop: Spacing.xs },\n  messageTime: { fontSize: 10, color: Colors.dark.textTertiary, fontFamily: Fonts?.mono },\n  typingContainer: { padding: Spacing.sm },\n  typingText: { fontSize: 12, color: Colors.dark.secondary, fontFamily: Fonts?.mono, fontStyle: \"italic\" },\n  inputContainer: { borderTopWidth: 1, borderTopColor: Colors.dark.border, paddingTop: Spacing.sm, paddingHorizontal: Spacing.md, backgroundColor: Colors.dark.backgroundRoot },\n  inputRow: { flexDirection: \"row\", alignItems: \"flex-end\", gap: Spacing.sm },\n  encryptToggle: { width: 40, height: 40, borderRadius: BorderRadius.sm, backgroundColor: Colors.dark.backgroundDefault, justifyContent: \"center\", alignItems: \"center\", borderWidth: 1, borderColor: Colors.dark.secondary },\n  encryptToggleOff: { borderColor: Colors.dark.danger },\n  textInputWrapper: { flex: 1, flexDirection: \"row\", alignItems: \"center\", backgroundColor: Colors.dark.backgroundDefault, borderRadius: BorderRadius.sm, borderWidth: 1, borderColor: Colors.dark.border, paddingHorizontal: Spacing.md, minHeight: 40, maxHeight: 100 },\n  prompt: { fontSize: 14, color: Colors.dark.secondary, fontFamily: Fonts?.mono, marginRight: Spacing.xs },\n  textInput: { flex: 1, fontSize: 14, color: Colors.dark.text, fontFamily: Fonts?.mono, paddingVertical: Spacing.sm },\n  sendButton: { width: 40, height: 40, borderRadius: BorderRadius.sm, backgroundColor: Colors.dark.primary, justifyContent: \"center\", alignItems: \"center\" },\n  sendButtonPressed: { opacity: 0.8 },\n  sendButtonDisabled: { backgroundColor: Colors.dark.backgroundSecondary },\n});\n","path":null,"size_bytes":11321,"size_tokens":null},"client/context/AuthContext.tsx":{"content":"import React, { createContext, useContext, useState, useEffect, useCallback } from \"react\";\nimport type { ReactNode } from \"react\";\nimport {\n  storeUser,\n  getStoredUser,\n  storeKeys,\n  getIdentityKey,\n  getSignedPreKey,\n  clearAllData,\n  type StoredUser,\n} from \"@/lib/storage\";\nimport { generateIdentityKeys, type KeyPair } from \"@/lib/crypto\";\nimport { emitUserOnline, disconnectSocket, getSocket } from \"@/lib/socket\";\nimport { apiRequest } from \"@/lib/query-client\";\n\ninterface AuthContextType {\n  user: StoredUser | null;\n  identityKey: KeyPair | null;\n  signedPreKey: KeyPair | null;\n  isLoading: boolean;\n  isAuthenticated: boolean;\n  register: (username: string) => Promise<void>;\n  login: (username: string) => Promise<void>;\n  logout: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<StoredUser | null>(null);\n  const [identityKey, setIdentityKey] = useState<KeyPair | null>(null);\n  const [signedPreKey, setSignedPreKey] = useState<KeyPair | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    async function loadUser() {\n      try {\n        const [storedUser, storedIdentityKey, storedSignedPreKey] = await Promise.all([\n          getStoredUser(),\n          getIdentityKey(),\n          getSignedPreKey(),\n        ]);\n\n        if (storedUser && storedIdentityKey && storedSignedPreKey) {\n          setUser(storedUser);\n          setIdentityKey(storedIdentityKey);\n          setSignedPreKey(storedSignedPreKey);\n          emitUserOnline(storedUser.id);\n        }\n      } catch (error) {\n        console.error(\"Failed to load user:\", error);\n      } finally {\n        setIsLoading(false);\n      }\n    }\n\n    loadUser();\n  }, []);\n\n  const register = useCallback(async (username: string) => {\n    const keys = generateIdentityKeys();\n    \n    const response = await apiRequest(\"POST\", \"/api/auth/register\", {\n      username,\n      publicKey: keys.identityKey.publicKey,\n      identityKey: keys.identityKey.publicKey,\n      signedPreKey: keys.signedPreKey.publicKey,\n    });\n\n    const userData = await response.json();\n\n    const storedUser: StoredUser = {\n      id: userData.id,\n      username: userData.username,\n      publicKey: userData.publicKey,\n      pairingCode: userData.pairingCode,\n    };\n\n    await Promise.all([\n      storeUser(storedUser),\n      storeKeys(keys.identityKey, keys.signedPreKey),\n    ]);\n\n    setUser(storedUser);\n    setIdentityKey(keys.identityKey);\n    setSignedPreKey(keys.signedPreKey);\n    emitUserOnline(storedUser.id);\n  }, []);\n\n  const login = useCallback(async (username: string) => {\n    const storedIdentityKey = await getIdentityKey();\n    const storedSignedPreKey = await getSignedPreKey();\n    \n    if (!storedIdentityKey || !storedSignedPreKey) {\n      throw new Error(\"No stored keys found. Please register first.\");\n    }\n\n    const response = await apiRequest(\"POST\", \"/api/auth/login\", { username });\n    const userData = await response.json();\n\n    const storedUser: StoredUser = {\n      id: userData.id,\n      username: userData.username,\n      publicKey: userData.publicKey,\n      pairingCode: userData.pairingCode,\n    };\n\n    await storeUser(storedUser);\n\n    setUser(storedUser);\n    setIdentityKey(storedIdentityKey);\n    setSignedPreKey(storedSignedPreKey);\n    emitUserOnline(storedUser.id);\n  }, []);\n\n  const logout = useCallback(async () => {\n    disconnectSocket();\n    await clearAllData();\n    setUser(null);\n    setIdentityKey(null);\n    setSignedPreKey(null);\n  }, []);\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        identityKey,\n        signedPreKey,\n        isLoading,\n        isAuthenticated: !!user,\n        register,\n        login,\n        logout,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth(): AuthContextType {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n}\n","path":null,"size_bytes":4129,"size_tokens":null},"client/components/Spacer.tsx":{"content":"import { View } from \"react-native\";\n\ntype Props = {\n  width?: number;\n  height?: number;\n};\n\nexport default function Spacer(props: Props) {\n  const width: number = props.width ?? 1;\n  const height: number = props.height ?? 1;\n\n  return (\n    <View\n      style={{\n        width,\n        height,\n      }}\n    />\n  );\n}\n","path":null,"size_bytes":318,"size_tokens":null},"client/lib/crypto.ts":{"content":"import nacl from \"tweetnacl\";\nimport naclUtil from \"tweetnacl-util\";\n\nexport interface KeyPair {\n  publicKey: string;\n  secretKey: string;\n}\n\nexport interface EncryptedMessage {\n  encryptedContent: string;\n  nonce: string;\n}\n\nexport function generateKeyPair(): KeyPair {\n  const keyPair = nacl.box.keyPair();\n  return {\n    publicKey: naclUtil.encodeBase64(keyPair.publicKey),\n    secretKey: naclUtil.encodeBase64(keyPair.secretKey),\n  };\n}\n\nexport function generateIdentityKeys(): {\n  identityKey: KeyPair;\n  signedPreKey: KeyPair;\n} {\n  return {\n    identityKey: generateKeyPair(),\n    signedPreKey: generateKeyPair(),\n  };\n}\n\nexport function encryptMessage(\n  message: string,\n  recipientPublicKey: string,\n  senderSecretKey: string\n): EncryptedMessage {\n  const nonce = nacl.randomBytes(nacl.box.nonceLength);\n  const messageUint8 = naclUtil.decodeUTF8(message);\n  const publicKeyUint8 = naclUtil.decodeBase64(recipientPublicKey);\n  const secretKeyUint8 = naclUtil.decodeBase64(senderSecretKey);\n\n  const encrypted = nacl.box(messageUint8, nonce, publicKeyUint8, secretKeyUint8);\n\n  return {\n    encryptedContent: naclUtil.encodeBase64(encrypted),\n    nonce: naclUtil.encodeBase64(nonce),\n  };\n}\n\nexport function decryptMessage(\n  encryptedContent: string,\n  nonce: string,\n  senderPublicKey: string,\n  recipientSecretKey: string\n): string | null {\n  try {\n    const encryptedUint8 = naclUtil.decodeBase64(encryptedContent);\n    const nonceUint8 = naclUtil.decodeBase64(nonce);\n    const publicKeyUint8 = naclUtil.decodeBase64(senderPublicKey);\n    const secretKeyUint8 = naclUtil.decodeBase64(recipientSecretKey);\n\n    const decrypted = nacl.box.open(\n      encryptedUint8,\n      nonceUint8,\n      publicKeyUint8,\n      secretKeyUint8\n    );\n\n    if (!decrypted) {\n      return null;\n    }\n\n    return naclUtil.encodeUTF8(decrypted);\n  } catch (error) {\n    console.error(\"Decryption error:\", error);\n    return null;\n  }\n}\n\nexport function generateSafetyNumber(\n  publicKey1: string,\n  publicKey2: string\n): string {\n  const combined = publicKey1 + publicKey2;\n  const hash = nacl.hash(naclUtil.decodeUTF8(combined));\n  const hashBase64 = naclUtil.encodeBase64(hash);\n  \n  const digits = hashBase64\n    .replace(/[^A-Za-z0-9]/g, \"\")\n    .substring(0, 60)\n    .toUpperCase();\n  \n  const groups = [];\n  for (let i = 0; i < digits.length; i += 5) {\n    groups.push(digits.substring(i, i + 5));\n  }\n  \n  return groups.join(\" \");\n}\n\nexport function generatePairingCode(): string {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n  let code = \"\";\n  const randomBytes = nacl.randomBytes(8);\n  for (let i = 0; i < 8; i++) {\n    code += chars[randomBytes[i] % chars.length];\n  }\n  return code;\n}\n","path":null,"size_bytes":2701,"size_tokens":null},"client/hooks/useColorScheme.ts":{"content":"export { useColorScheme } from \"react-native\";\n","path":null,"size_bytes":47,"size_tokens":null},"client/components/KeyboardAwareScrollViewCompat.tsx":{"content":"import { Platform, ScrollView, ScrollViewProps } from \"react-native\";\nimport {\n  KeyboardAwareScrollView,\n  KeyboardAwareScrollViewProps,\n} from \"react-native-keyboard-controller\";\n\ntype Props = KeyboardAwareScrollViewProps & ScrollViewProps;\n\n/**\n * KeyboardAwareScrollView that falls back to ScrollView on web.\n * Use this for any screen containing text inputs.\n */\nexport function KeyboardAwareScrollViewCompat({\n  children,\n  keyboardShouldPersistTaps = \"handled\",\n  ...props\n}: Props) {\n  if (Platform.OS === \"web\") {\n    return (\n      <ScrollView\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        {...props}\n      >\n        {children}\n      </ScrollView>\n    );\n  }\n\n  return (\n    <KeyboardAwareScrollView\n      keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n      {...props}\n    >\n      {children}\n    </KeyboardAwareScrollView>\n  );\n}\n","path":null,"size_bytes":872,"size_tokens":null},"client/hooks/useTheme.ts":{"content":"import { Colors } from \"@/constants/theme\";\nimport { useColorScheme } from \"@/hooks/useColorScheme\";\n\nexport function useTheme() {\n  const colorScheme = useColorScheme();\n  const isDark = colorScheme === \"dark\";\n  const theme = Colors[colorScheme ?? \"light\"];\n\n  return {\n    theme,\n    isDark,\n  };\n}\n","path":null,"size_bytes":302,"size_tokens":null},"client/components/ThemedText.tsx":{"content":"import { Text, type TextProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Typography } from \"@/constants/theme\";\n\nexport type ThemedTextProps = TextProps & {\n  lightColor?: string;\n  darkColor?: string;\n  type?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body\" | \"small\" | \"link\";\n};\n\nexport function ThemedText({\n  style,\n  lightColor,\n  darkColor,\n  type = \"body\",\n  ...rest\n}: ThemedTextProps) {\n  const { theme, isDark } = useTheme();\n\n  const getColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n\n    if (type === \"link\") {\n      return theme.link;\n    }\n\n    return theme.text;\n  };\n\n  const getTypeStyle = () => {\n    switch (type) {\n      case \"h1\":\n        return Typography.h1;\n      case \"h2\":\n        return Typography.h2;\n      case \"h3\":\n        return Typography.h3;\n      case \"h4\":\n        return Typography.h4;\n      case \"body\":\n        return Typography.body;\n      case \"small\":\n        return Typography.small;\n      case \"link\":\n        return Typography.link;\n      default:\n        return Typography.body;\n    }\n  };\n\n  return (\n    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />\n  );\n}\n","path":null,"size_bytes":1251,"size_tokens":null}},"version":2}